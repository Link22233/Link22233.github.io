<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DP 优化笔记：当“空间换时间”遇到内存超限</title>
    <link href="/2025/10/19/DP%20%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%93%E2%80%9C%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E2%80%9D%E9%81%87%E5%88%B0%E5%86%85%E5%AD%98%E8%B6%85%E9%99%90/"/>
    <url>/2025/10/19/DP%20%E4%BC%98%E5%8C%96%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%93%E2%80%9C%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E2%80%9D%E9%81%87%E5%88%B0%E5%86%85%E5%AD%98%E8%B6%85%E9%99%90/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="DP-优化笔记：当“空间换时间”遇到内存超限"><a href="#DP-优化笔记：当“空间换时间”遇到内存超限" class="headerlink" title="DP 优化笔记：当“空间换时间”遇到内存超限"></a>DP 优化笔记：当“空间换时间”遇到内存超限</h3><h4 id="核心问题：动态规划不就是用空间换时间吗？为什么又不让算法用内存了呢"><a href="#核心问题：动态规划不就是用空间换时间吗？为什么又不让算法用内存了呢" class="headerlink" title="核心问题：动态规划不就是用空间换时间吗？为什么又不让算法用内存了呢"></a>核心问题：动态规划不就是用空间换时间吗？为什么又不让算法用内存了呢</h4><p>你提出了一个非常深刻的问题，这正是动态规划的核心思想。这个“交换”是有限度的，我们可以用一个比喻来理解：</p><p><strong>把 DP 的“空间换时间”想象成你在一个工作台上组装一个复杂的模型。</strong></p><ol><li><p>**理想情况 (无限空间)**： 你有一个无限大的工作台。你可以把模型说明书的每一步（比如第1步到第100步）用到的所有零件、半成品，全都摊在桌子上。当进行到第50步时，你需要一个第49步的组件，一伸手就能拿到，非常快。这就是用巨大的空间（工作台）换来了速度（时间）。 这对应了我们最开始的 <code>dp[n+1][n+1]</code> 方案。</p></li><li><p>**现实情况 (有限空间)**： 现在比赛的规则是，你只有一个很小的书桌来组装模型。你不可能把100个步骤的所有零件都摊开，那样桌子会立刻被堆满，你什么也做不了。 这就是“内存超限”。判题系统给你的内存（书桌）是有限的。</p></li></ol><p><strong>那么，聪明的做法是什么呢？</strong></p><p>你会发现，在组装第50步的时候，你其实<strong>只需要</strong>第49步的那个半成品。至于第1步、第2步、甚至第48步的那些零件，你暂时都用不着了。</p><p>所以，你只在桌上保留<strong>【上一步用完的组件】</strong>和<strong>【这一步正在用的零件】</strong>。每完成一步，就把更早的、暂时用不上的零件先收回盒子里。这样，你的小书桌就始终够用了。</p><p>这对应的就是我们的<strong>“滚动数组”</strong>优化方案 <code>dp[2][n+1]</code>。我们没有放弃“用空间换时间”的思路（我们仍然保留了上一行的结果），而是把它优化到了一个更高效的水平——我们只保留了<strong>绝对必要</strong>的空间。</p><p>现在，让我们回到状态转移的逻辑上。在计算<strong>第 <code>i</code> 行</strong>的结果时，我们唯一需要参考的是不是就是<strong>第 <code>i-1</code> 行</strong>的数据？</p><hr><h4 id="问题诊断：内存超限-Memory-Limit-Exceeded"><a href="#问题诊断：内存超限-Memory-Limit-Exceeded" class="headerlink" title="问题诊断：内存超限 (Memory Limit Exceeded)"></a>问题诊断：内存超限 (Memory Limit Exceeded)</h4><ul><li><p><strong>根源分析</strong>：<code>long[][] dp = new long[n + 1][n + 1];</code></p></li><li><p>问题所在：当 n &#x3D; 200,000 时，这张 DP 表需要的总内存大约是：</p><p>  200,001 * 200,001 * 8 字节 ≈ 320 GB</p></li><li><p><strong>结论</strong>：这个内存需求远超比赛通常几百MB的限制，导致程序被终止。</p></li></ul><h4 id="问题：我看不懂“滚动数组”优化方案-dp-2-n-1-怎么办？"><a href="#问题：我看不懂“滚动数组”优化方案-dp-2-n-1-怎么办？" class="headerlink" title="问题：我看不懂“滚动数组”优化方案 $dp[2][n+1]$ 怎么办？"></a>问题：我看不懂“滚动数组”优化方案 $dp[2][n+1]$ 怎么办？</h4><p>没问题，我们把这个抽象的概念变得具体一点。“滚动数组”听起来很复杂，但它的思想其实非常简单。</p><p>我们用一个比喻来理解：<strong>两块小黑板</strong>。</p><ul><li><p>**原来的方法 <code>dp[n+1][n+1]</code>**：就像我们有 n 块黑板，一块给第1只怪物用，一块给第2只用……一直到第n只。当 n 是20万时，我们就需要20万块黑板，房间（内存）肯定放不下。</p></li><li><p><strong>“滚动数组” <code>dp[2][n+1]</code><strong>：我们发现，在计算第 i 只怪物的情况时，其实只需要参考第 i-1 只怪物的结果就行了。于是我们说：“我们不需要20万块黑板，我们只需要</strong>两块</strong>就够了！” 我们把它们叫做<strong>黑板A</strong>和<strong>黑板B</strong>。</p></li></ul><p>现在我们来看看这两块黑板是怎么“滚动”工作的：</p><ol><li><p><strong>开始 (第0步)</strong>: 我们在<strong>黑板A</strong>上写下初始状态（经验为0）。</p></li><li><p><strong>计算第1只怪物</strong>:</p><ul><li><p>我们看着<strong>黑板A</strong>（上一行的数据）。</p></li><li><p>根据黑板A的数据算出第1只怪的所有结果。</p></li><li><p>我们把这些新结果写在<strong>黑板B</strong>上。</p></li></ul></li><li><p><strong>计算第2只怪物</strong>:</p><ul><li><p>现在我们只需要看<strong>黑板B</strong>了（它现在是“上一行”的数据）。</p></li><li><p>根据黑板B的数据算出第2只怪的所有结果。</p></li><li><p>我们把这些新结果写回到<strong>黑板A</strong>上（因为黑板A的旧数据已经没用了，可以擦掉）。</p></li></ul></li><li><p><strong>计算第3只怪物</strong>:</p><ul><li><p>我们再回头看<strong>黑板A</strong>（它又是“上一行”了）。</p></li><li><p>算出结果，再写回到<strong>黑板B</strong>上。</p></li></ul></li></ol><p>你看，我们就在这两块黑板之间来回擦写。一块始终保存着【上一行】的结果，另一块用来计算【当前行】的结果。这就是“滚动”的含义。</p><hr><p>那么在代码里，我们如何区分哪块是“当前行”，哪块是“上一行”呢？我们用了一个小技巧：**取模运算 <code>% 2</code>**。</p><ul><li><p>当 <code>i</code> 是 1, 3, 5… (奇数) 时, <code>i % 2</code> 的结果是 <strong>1</strong>。</p></li><li><p>当 <code>i</code> 是 2, 4, 6… (偶数) 时, <code>i % 2</code> 的结果是 <strong>0</strong>。</p></li></ul><p><code>dp[0]</code> 就是黑板A，<code>dp[1]</code> 就是黑板B。<code>i % 2</code> 巧妙地帮我们决定了当前该用哪块黑板。</p><p>currentRow &#x3D; i % 2;</p><p>prevRow &#x3D; (i - 1) % 2;当前行 &#x3D; i % 2; 上一行 &#x3D; （i - 1） % 2;</p><p>这个技巧确保了我们总能从正确的“上一行”读取数据，读取上一步的结果，然后把算出来的新结果覆盖掉更早的、已经没用的数据。</p><hr><h4 id="这个技巧是如何解决“内存超限”问题的？当-n-200-000-时，dp-n-1-n-1-和-dp-2-n-1-在内存占用上有什么根本性的区别？"><a href="#这个技巧是如何解决“内存超限”问题的？当-n-200-000-时，dp-n-1-n-1-和-dp-2-n-1-在内存占用上有什么根本性的区别？" class="headerlink" title="这个技巧是如何解决“内存超限”问题的？当 n &#x3D; 200,000 时，dp[n+1][n+1] 和 dp[2][n+1] 在内存占用上有什么根本性的区别？"></a>这个技巧是如何解决“内存超限”问题的？当 n &#x3D; 200,000 时，<code>dp[n+1][n+1]</code> 和 <code>dp[2][n+1]</code> 在内存占用上有什么根本性的区别？</h4><p>减少了 n-1 行 n+1 的数据的存储</p><ul><li><p><code>dp[n+1][n+1]</code> 方案需要存储 <code>n+1</code> 行数据。</p></li><li><p><code>dp[2][n+1]</code> 方案只需要存储 <code>2</code> 行数据。</p></li></ul><p>我们减少了 <code>(n+1) - 2 = n-1</code> 行的数据存储。</p><p>当 <code>n = 200,000</code> 时，这个区别是天壤之别：</p><ul><li><p><strong>旧方案</strong>：需要大约 <strong>320 GB</strong> 的内存。</p></li><li><p><strong>新方案</strong>：只需要大约 <strong>3.2 MB</strong> 的内存。</p></li></ul><p>这就是滚动数组如何解决了“内存超限”的问题。你已经完全理解了第一个优化。</p><hr><p>好，现在我们可以安心地进入第二个问题了：**运行超时 (Time Limit Exceeded)**。</p><p>我们成功地把内存压下来了，但程序在大数据量下还是太慢了。你认为我们代码的哪一部分是主要的“耗时大户”呢？</p><hr><h4 id="最终代码实现"><a href="#最终代码实现" class="headerlink" title="最终代码实现"></a>最终代码实现</h4><p>Java  爪哇岛</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title">maxExperience</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">long</span>[] a)</span> </span>&#123;<br>    <span class="hljs-comment">// 空间优化：只使用两行来回滚动</span><br>    <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-type">long</span>[<span class="hljs-number">2</span>][n + <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 初始化这两行</span><br>    Arrays.<span class="hljs-built_in">fill</span>(dp[<span class="hljs-number">0</span>], Long.MIN_VALUE);<br>    Arrays.<span class="hljs-built_in">fill</span>(dp[<span class="hljs-number">1</span>], Long.MIN_VALUE);<br>    <br>    <span class="hljs-comment">// 起点不变，写在第0行</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// 计算当前行和上一行的索引</span><br>        <span class="hljs-type">int</span> currentRow = i % <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> prevRow = (i - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-comment">// (重要) 重置当前行，擦掉 i-2 行的旧数据</span><br>        Arrays.<span class="hljs-built_in">fill</span>(dp[currentRow], Long.MIN_VALUE);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-type">long</span> exp_let_go = Long.MIN_VALUE;<br>            <span class="hljs-comment">// 从上一行 prevRow 获取状态</span><br>            <span class="hljs-keyword">if</span> (dp[prevRow][j] != Long.MIN_VALUE) &#123;<br>                exp_let_go = dp[prevRow][j] + i;<br>            &#125;<br>            <br>            <span class="hljs-type">long</span> exp_defeat = Long.MIN_VALUE;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; dp[prevRow][j - <span class="hljs-number">1</span>] != Long.MIN_VALUE) &#123;<br>                <span class="hljs-comment">// 从上一行 prevRow 获取状态</span><br>                exp_defeat = dp[prevRow][j - <span class="hljs-number">1</span>] + a[i - <span class="hljs-number">1</span>] + (<span class="hljs-type">long</span>)(j % <span class="hljs-number">10</span>) * a[i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <br>            <span class="hljs-comment">// 结果存入当前行 currentRow</span><br>            dp[currentRow][j] = Math.<span class="hljs-built_in">max</span>(exp_let_go, exp_defeat);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 查找最终答案</span><br>    <span class="hljs-type">int</span> finalRow = n % <span class="hljs-number">2</span>; <span class="hljs-comment">// 最后一行的索引是 n % 2</span><br>    <span class="hljs-type">long</span> maxResult = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>        maxResult = Math.<span class="hljs-built_in">max</span>(maxResult, dp[finalRow][j]);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> maxResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>与<a href="https://link22233.github.io/2025/10/18/%E6%88%91%E7%9A%84%20DP%20%E6%8E%A2%E9%99%A9%E5%AE%9E%E5%BD%95%EF%BC%9A%E4%BB%8E%E2%80%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E2%80%9D%E5%88%B0%E2%80%9C%E6%88%91%E6%87%82%E4%BA%86%E2%80%9D/">小红打怪</a>的初始代码相比，代码里最重要的变化就是第3、5、6步：</p><ul><li><p>我们用 <code>i % 2</code> 巧妙地在索引 <code>0</code> 和 <code>1</code> 之间切换，模拟“滚动”的效果。</p></li><li><p>我们总是从 <code>prevRow</code> 读取数据，向 <code>currentRow</code> 写入新数据。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DP</tag>
      
      <tag>算法优化</tag>
      
      <tag>滚动数组</tag>
      
      <tag>内存超限</tag>
      
      <tag>空间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的 DP 探险实录：从“为什么”到“我懂了”</title>
    <link href="/2025/10/18/%E6%88%91%E7%9A%84%20DP%20%E6%8E%A2%E9%99%A9%E5%AE%9E%E5%BD%95%EF%BC%9A%E4%BB%8E%E2%80%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E2%80%9D%E5%88%B0%E2%80%9C%E6%88%91%E6%87%82%E4%BA%86%E2%80%9D/"/>
    <url>/2025/10/18/%E6%88%91%E7%9A%84%20DP%20%E6%8E%A2%E9%99%A9%E5%AE%9E%E5%BD%95%EF%BC%9A%E4%BB%8E%E2%80%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E2%80%9D%E5%88%B0%E2%80%9C%E6%88%91%E6%87%82%E4%BA%86%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p>大家好，我刚刚经历了一场酣畅淋漓的“思维战斗”，对手是——动态规划（DP）。我决定把这次宝贵的经历写下来。这篇笔记并非总结，而是一份忠实还原我学习过程的对话实录。它将包含我提出的每一个问题，以及那些最终让我豁然 KAI 朗的、未经编辑的回答。</p><h3 id="探险起点：一张看似简单的“藏宝图”"><a href="#探险起点：一张看似简单的“藏宝图”" class="headerlink" title="探险起点：一张看似简单的“藏宝图”"></a>探险起点：一张看似简单的“藏宝图”</h3><p>我拿到的题目是这样的：</p><blockquote><p>有 n 只怪物，编号从 1 到 n。对于每只怪物，你都可以选择“放走”或“击败”。</p><ul><li><strong>放走</strong>第 i 只怪物：获得 i 点经验。</li><li><strong>击败</strong>第 i 只怪物：获得 a[i] 点经验，并额外获得 <code>(x % 10) * a[i]</code> 点经验，其中 x 是你到目前为止总共击败的怪物数量（包括这一只）。</li></ul><p><strong>目标：</strong> 找到你最多可以获得的总经验值。</p></blockquote><hr><h3 id="序章：拨开迷雾——我们到底需要什么工具？"><a href="#序章：拨开迷雾——我们到底需要什么工具？" class="headerlink" title="序章：拨开迷雾——我们到底需要什么工具？"></a>序章：拨开迷雾——我们到底需要什么工具？</h3><p>这是我们对话的最早阶段，我们试图弄清楚这个问题的本质。</p><blockquote><p><strong>我的问题：</strong> “为了能算出击败怪物能得多少经验，我们需要知道一个什么关键信息呢？”<br><strong>我当时的回答是：</strong> “怪物血量 a[i]”。</p></blockquote><p><strong>引导我的回答：</strong></p><p>你说得对，怪物血量 a[i] 肯定是需要的。但我们再仔细看看击败怪物的规则：“额外获得 (x mod 10) * a[i] 点经验值，x 为击败怪物数量”。这里的 x 是什么？它是固定的吗，还是会随着我们的选择而变化？</p><blockquote><p><strong>我的问题：</strong> （在意识到 x 是“击败过的数量”后）“这种‘一步一步解决，并且每一步都依赖于之前步骤的结果’的思路，通常指向哪种经典的算法思想？”<br><strong>我当时的回答是：</strong> “递归”。</p></blockquote><p><strong>让我明白的回答：</strong></p><p>递归是一个非常好的思路！这说明你已经看到了这个问题“向前依赖”的特性。当一个问题可以被分解成子问题，并且子问题的解可以被重复使用时，单纯的递归可能会很慢。我们有一种更优化的方法，它本质上是聪明的递归，通过记录和重用子问题的答案来避免重复计算。这个方法叫什么呢？它和“动态”有关。</p><p>在引导下，我得出了答案：“动态规划”。</p><hr><h3 id="第一站：艰难地绘制地图——定义-dp-状态"><a href="#第一站：艰难地绘制地图——定义-dp-状态" class="headerlink" title="第一站：艰难地绘制地图——定义 dp 状态"></a>第一站：艰难地绘制地图——定义 dp 状态</h3><p>确定了要用 DP，但我立刻卡在了最基础的一步。</p><blockquote><p><strong>我的问题：</strong> “在动态规划里，最关键的第一步是定义‘状态’。Dp[i][j] 这个格子里应该存放什么数值，才能最终帮我们找到答案呢？”<br><strong>我当时的回答是：</strong> “我不懂了”。</p></blockquote><p><strong>让我明白的回答：</strong></p><p>没问题，定义状态是动态规划里最关键也最需要思考的一步。我们一起把它弄清楚。我们这个问题的最终目标是什么？是不是要求一个“最多可以获得的经验值”？那么，我们的 dp 表就应该用来记录这个值。所以，<code>dp[i][j]</code> 就代表：<strong>在考虑了前 i 只怪物，并且总共击败了 j 只的情况下，我们能获得的最大经验值是多少</strong>。</p><blockquote><p><strong>我的问题：</strong> （在计算“放走”的情况时）“我已经弄不清各个字母代表什么了。”</p></blockquote><p><strong>让我明白的回答：</strong></p><p>当然，这些字母确实容易搞混。我们放慢速度，把它们弄清楚。记住我们的定义：<code>dp[i][j]</code> &#x3D; 考虑完前 i 只怪物，并且总共击败了 j 只时的最高总经验。现在，我们只专注于一个选择：<strong>放走</strong>第 i 只怪物。如果到第 i 只怪物为止，我们总共击败了 j 只怪物，而第 i 只又是被我们放走的。这意味着，在我们处理完前面 i-1 只怪物时，我们<strong>已经</strong>击败了 j 只。</p><hr><h3 id="第二站：搭建我的“算法实验室”——从理论到实践"><a href="#第二站：搭建我的“算法实验室”——从理论到实践" class="headerlink" title="第二站：搭建我的“算法实验室”——从理论到实践"></a>第二站：搭建我的“算法实验室”——从理论到实践</h3><p>在深入思考 DP 的核心逻辑之前，我首先在如何将理论付诸实践上遇到了一系列问题。</p><blockquote><p><strong>我的问题：</strong> “我需要单独写函数该怎么写？我想模拟 LeetCode 模式。”</p></blockquote><p><strong>让我明白的回答：</strong></p><p>这是一个非常好的问题！这正是 LeetCode 和普通编程练习最大的区别。在 LeetCode 上，你不需要写 <code>main</code> 方法，而是要填充一个已经定义好的函数。</p><h4 id="LeetCode-的代码结构"><a href="#LeetCode-的代码结构" class="headerlink" title="LeetCode 的代码结构"></a>LeetCode 的代码结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxExperience</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">long</span>[] a)</span> &#123;<br>        <span class="hljs-comment">// 你的代码写在这里</span><br>        <span class="hljs-comment">// 最后，你需要返回一个 long 类型的结果</span><br>        <span class="hljs-comment">// return ...;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结一下转变：</strong></p><ul><li><p><strong>输入</strong>：从 <code>Scanner</code> 读取 -&gt; 从函数参数 <code>n</code> 和 <code>a</code> 获取。</p></li><li><p><strong>输出</strong>：从 <code>System.out.println()</code> 打印 -&gt; 用 <code>return maxExperience;</code> 返回。</p></li></ul><blockquote><p><strong>我的问题：</strong> “那我怎么在本地测试这段 LeetCode 代码呢？”</p></blockquote><p><strong>让我明白的回答（测试分离模式）：</strong></p><p>你不能直接运行 <code>Solution.java</code>，因为它没有 <code>main</code> 方法。你需要创建另一个文件来“扮演” LeetCode 的角色：调用你的 <code>Solution</code> 类。</p><ol><li><p>保持 <code>Solution.java</code> 文件不变。</p></li><li><p>在同一个文件夹下，新建一个文件，比如叫 <code>Main.java</code>。</p></li><li><p>把测试代码粘贴到 <code>Main.java</code> 中，运行 <code>Main.java</code> 文件。</p></li></ol><blockquote><p><strong>我的问题：</strong> “为什么我运行 Main.java 报错了？提示 <code>错误: 找不到符号 Solution</code>”</p></blockquote><p><strong>让我明白的回答：</strong></p><p>你遇到了一个非常经典，每个 Java 程序员都肯定会遇到的错误！这不是你算法逻辑的问题，而是 Java 文件编译方式的问题。这句报错的“人话”翻译就是：“我在编译 <code>Main.java</code>，读到 <code>Solution solution = new Solution();</code> 的时候，我完全不认识 <code>Solution</code> 是个什么东西。”</p><p>最简单的解决方法 (推荐)</p><p>在 VS Code 中，使用编辑器自带的<strong>“Run”按钮</strong>，而不是在下方的终端里手动输入编译命令。直接点击 main 方法上方的 “Run”。IDE 会足够智能地帮我们编译所有相关的文件。</p><blockquote><p><strong>我的问题：</strong> “我怎么看到 dp 表格的具体情况？”</p></blockquote><p><strong>让我明白的回答（调试器的威力）：</strong></p><p>绝对可以，而且这正是调试器（Debugger）最强大的功能之一！</p><ol><li><p>**设置断点 (Breakpoint)**： 在代码行的行号左边，用鼠标单击一下，就会出现一个红点。最好的位置是在双重循环的内部。</p></li><li><p><strong>启动调试</strong>： 不要点击“Run”按钮，而是要选择“运行和调试”（通常快捷键是 F5）。</p></li><li><p><strong>查看 dp 表</strong>： 程序在断点处暂停后，在 VS Code 的左侧<strong>“变量 (VARIABLES)”</strong>窗口中，找到你的 <code>dp</code> 数组。点击箭头展开它，你就可以看到它所有的行和列！</p></li></ol><blockquote><p><strong>我的问题：</strong> “为什么我在调试器里看到的 dp 表，和手画的带表头的表格不一样？还有一堆巨大的负数？”</p></blockquote><p><strong>让我明白的回答：</strong></p><p>你的观察完全正确。根本原因在于：一个是给计算机看的“原始数据” 🖥️，另一个是给我了们人类看的“格式化报告” 📖。</p><p>而那些巨大的负数，是因为你的断点设在了循环中间，程序暂停时，dp 表的填充只进行到了一半！ 那些负数（<code>Long.MIN_VALUE</code>）是你设置的初始值，代表“这个格子还没轮到计算”。你看到的不是错误，而是动态规划<strong>正在施工中的样子</strong>！</p><hr><h3 id="第三站：探寻法则——最深刻的思辨之旅"><a href="#第三站：探寻法则——最深刻的思辨之旅" class="headerlink" title="第三站：探寻法则——最深刻的思辨之旅"></a>第三站：探寻法则——最深刻的思辨之旅</h3><p>在解决了实践操作问题后，我开始深入思考 DP 的核心逻辑。</p><blockquote><p><strong>我的问题：</strong> “我不知道为什么要用 <code>max()</code> 函数，dp 难道不是记录我选择击败或放走后的结果吗？”</p></blockquote><p><strong>让我明白的回答：</strong></p><p>你这个想法非常接近核心了！你说得对，dp 表确实记录了结果，但它记录的不是一个随便的结果，而是一个<strong>“最优”</strong>的结果。</p><p>我们把你的想法拆解一下，看看会发生什么。</p><p>假设我们不用 Math.max()，而是让 dp 表记录所有可能路径的结果。当我们要计算“处理完3只怪，击败2只”的最高分时，有多少种可能的路径呢？</p><ul><li><p>路径1: 击败-击败-放走</p></li><li><p>路径2: 击败-放走-击败</p></li><li><p>路径3: 放走-击败-击败</p><p>  我们需要把这3条路的得分全都分别算一遍，然后比较大小。这还只是 dp[3][2] 一个格子。当我们计算 dp[n][j] 时，需要追溯的路径数量会像爆炸一样增多，算法就变得非常非常慢了。</p></li></ul><p><strong><code>Math.max()</code> 的魔法 ✨</strong></p><p>Math.max() 让我们避免了这种麻烦。它让我们的 dp 表变得更“聪明”。</p><p>dp[i][j] 记录的不是：“我通过‘放走’这条路来到了 (i,j) 这个状态”。</p><p>它记录的是：“不管你是怎么来的（可能是放走，也可能是击败），所有能到达 (i, j) 这个状态的路径中，最高分就是我记录的这个数。”</p><p>再用那个十字路口的比喻：</p><ul><li><p><code>exp_let_go</code> 是一条通往 <code>(i, j)</code> 这个目的地的路。</p></li><li><p>exp_defeat 是另一条通往同一个目的地 (i, j) 的路。</p><p>  dp[i][j] 这个格子，就像是目的地 (i, j) 的一块冠军奖牌。我们不关心冠军是怎么跑来的，我们只把奖牌发给那个分数最高的路径。Math.max() 就是那个裁判，它比较了两条路的分数，然后把冠军分数刻在了奖牌上。</p></li></ul><p>这样，当下一个人（<code>dp[i+1][...]</code>）需要参考这个目的地的分数时，他不需要知道复杂的历史，只需要看一眼奖牌上的分数，因为他知道那已经是这里的最高记录了。</p><p>所以，dp 表记录的确实是选择之后的结果，但它非常聪明地<strong>只记录了那个最优的结果，扔掉了所有不好的选择</strong>，这就是动态规划高效的秘密。</p><blockquote><p><strong>我的问题：</strong> “那些不好的选择怎么抛弃的？我还能在 dp 表里找到‘放走-放走-放走’的分数吗？”</p></blockquote><p><strong>让我明白的回答：</strong></p><p>绝佳的问题！这能让我们彻底看清 dp 表的本质。</p><p>答案是：是的，你绝对可以在最终的 dp 表里找到“放走-放走-放走”这条路径的分数！ 它就藏在 dp 表的一个特定格子里。</p><p>我们来追踪一下这条路径在 dp 表上的“地址”：</p><ul><li><p>第1步：放走第1只怪 -&gt; 它的分数被记录在 <code>dp[1][0]</code>。</p></li><li><p>第2步：放走第2只怪 -&gt; 它的分数被记录在 <code>dp[2][0]</code>。</p></li><li><p>第3步：放走第3只怪 -&gt; 它的最终分数被记录在 <code>dp[3][0]</code>。</p></li></ul><p>最终的 dp 表中 <code>dp[3][0]</code> 的值正好是 6。</p><p>那么，这是否和我之前说的“坏选择会被抛弃”矛盾呢？</p><p>一点也不矛盾，这反而完美地解释了 DP 的原理！</p><p><code>dp[i][j]</code> 记录的是：所有能够到达 <code>(i, j)</code> 这个状态的路径中，分数最高的那条路的分数。</p><p>对于 <code>dp[3][0]</code> 这个格子，要达到“处理3只怪，击败0只”的状态，有且<strong>仅有</strong>“放走-放走-放走”这一条路。没有其他竞争者。所以它自己就是冠军，它的分数 6 就被记录了下来。</p><p>但是对于 <code>dp[2][1]</code> 这个格子，要达到“处理2只怪，击败1只”的状态，我们发现了两条路：</p><ol><li><p>击败-放走，分数为 12。</p></li><li><p>放走-击败，分数为 7。</p></li></ol><p>在这里，<code>Math.max()</code> 充当了裁判，它选择了 12 这条路，把分数 12 写入了 <code>dp[2][1]</code>，而分数 7 和它背后的那条 <code>放走-击败</code> 路径，就被永远地<strong>抛弃</strong>了。</p><blockquote><p><strong>我的问题：</strong> “那‘放走-击败-放走’的路径是不是找不到了？”</p></blockquote><p><strong>让我明白的回答：</strong></p><p>你说得完全正确。</p><p>“放走-击败-放走”这条特定路径的真实分数，在最终的 dp 表里是找不到的。</p><p>你已经触及到了动态规划最核心的“剪枝”思想。我们来当一次侦探，看看这条路径是在哪里“消失”的。</p><p><strong>案件重演：一条路径的消失</strong></p><ul><li><p><strong>起点</strong>： 我们要追踪的路径是 <code>放走 - 击败 - 放走</code>。</p></li><li><p><strong>第二步</strong>：处理第2只怪，选择【击败】。这条路径现在要从 <code>(i=1, j=0)</code> 前往 <code>(i=2, j=1)</code>。我们计算一下它的得分：<code>dp[1][0] + a[1] + (1 % 10) * a[1] = 1 + 3 + 1*3 = 7分</code>。</p></li><li><p><strong>关键时刻来了！</strong> 此时，还有另一条路径也到达了 <code>(i=2, j=1)</code> 这个目的地，那就是 <code>击败 - 放走</code> 路径，它的得分是 <strong>12分</strong>。</p></li><li><p>**审判时刻 (Math.max)**：在 <code>dp[2][1]</code> 这个格子上，两条路径相遇了。裁判 <code>Math.max(12, 7)</code> 宣布：12分胜出！</p></li><li><p><strong>结果</strong>：于是，数字 12 被写入了 <code>dp[2][1]</code>。而我们那条路径得到的 7 分，以及它背后的历史 <code>放走-击败</code>，就在这一刻被彻底抛弃了。它输掉了比赛，没有资格被记录下来。</p></li></ul><blockquote><p><strong>我的问题：</strong> “那如果另一个给怪的情况下‘放走-击败-放走’的分数更高怎么办，它不就被放弃了吗？” &amp; “我还是不太理解。”</p></blockquote><p><strong>让我明白的回答（登山的故事）：</strong></p><p>这是动态规划最神奇也最反直觉的地方。如果“放走-击败-放走”这条路在未来有潜力获得更高分，它就<strong>绝对不会被放弃</strong>。</p><p>这里的奥秘在于，动态规划基于一个非常重要的原则，叫做<strong>“最优子结构”</strong>。用大白话说就是：</p><blockquote><p>一个最优的全局策略，它的每一个局部步骤也必然是这个局部的最优策略。</p></blockquote><p><strong>登山故事的续集：公平的未来</strong></p><p>你和你的朋友，肩并肩地站在 <code>站(2, 1)</code>。</p><ul><li><p>你口袋里有 12 个宝物。</p></li><li><p>你朋友口袋里只有 7 个宝物。</p></li></ul><p><strong>关键问题：谁的未来更有希望？</strong></p><p>从 <code>站(2, 1)</code> 出发，前往山顶的剩下的路，对于你和你朋友来说，是<strong>完全一模一样的</strong>。如果你们下一步都走平坦小路，都会额外获得 +3 分。</p><ul><li><p>你的总分会变成 <code>12 + 3 = 15</code>。</p></li><li><p>你朋友的总分会变成 <code>7 + 3 = 10</code>。</p></li></ul><p>因为你朋友在到达 <code>站(2, 1)</code> 时就已经落后了，并且未来的道路对你们是公平的，所以他没有任何机会再反超你了。他过去犯下的“错误选择”所导致的差距，是永远无法弥补的。</p><p>这就是 <code>Math.max()</code> 能够“放心”抛弃坏选择的底气所在。它所解决的问题满足一个叫做<strong>“无后效性”</strong>的原则：一旦某个状态确定了，那么这个状态之前的历史就不会再影响未来的决策。</p><blockquote><p><strong>我的问题：</strong> “但是dp[2,1]本身不就是在未来会被抛弃的路径吗？”</p></blockquote><p><strong>让我明白的回答（分站冠军 vs. 全程总冠军）：</strong></p><p>这是一个绝妙的问题！你说的完全正确！<code>dp[2,1]</code> 这个格子本身，确实可能位于一条最终被抛弃的宏观路径上。</p><p>这恰好是两个不同层面的“胜利”。我们必须区分：</p><ol><li><p><strong>子问题的冠军</strong> (一个格子的值)</p></li><li><p><strong>全局问题的总冠军</strong> (最终答案)</p></li></ol><p><strong>登山故事的最终章：分站冠军 vs. 全程总冠军</strong></p><p>dp[2,1] &#x3D; 12。这是所有能够到达 站(2, 1) 的路线中，最快的那条路线的成绩。我们称之为 “站(2, 1) 分站冠军”。</p><p>dp[2,2] &#x3D; 19。这是所有能够到达 站(2, 2) 的路线中，最快的那条路线的成绩。我们称之为 “站(2, 2) 分站冠军”。</p><p>当我们站在山顶回望时，我们发现，那个最终赢得全程总冠军的人，他选择的路线根本就**没有经过 <code>站(2, 1)</code>**！他走的是经过 <code>站(2, 2)</code> 的那条路。</p><p>总结：</p><p>dp 表格的伟大之处在于，它不预设哪条路是最好的。它非常公平地计算出了每一个可能子状态的最优解（每一个分站冠军），把它们全都记录下来。然后，它再利用这些已经算好的、可靠的“分站冠军”成绩，去构建下一阶段的比赛，最终决出唯一的“全程总冠军”。我们必须算出 dp[2,1] 的值，即使它最后没被用上。因为在没算完之前，我们无法预知最终的冠军路径会不会经过它。</p><hr><h3 id="我的藏宝图（最终代码）"><a href="#我的藏宝图（最终代码）" class="headerlink" title="我的藏宝图（最终代码）"></a>我的藏宝图（最终代码）</h3><p>Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">maxExperience</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">long</span>[] a)</span> &#123;<br>        <span class="hljs-comment">// 我的记分板：dp[i][j] -&gt; 处理完前 i 只怪，击败 j 只的最高分</span><br>        <span class="hljs-type">long</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">// 初始化记分板，所有格子都标记为“不可达”</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span>[] row : dp) &#123;<br>            Arrays.fill(row, Long.MIN_VALUE);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 探险的起点：游戏开始前，经验为0</span><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 开始一关一关地填写记分板</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-comment">// 计算第 i 关的所有可能状态（击败 0 次到 i 次）</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <br>                <span class="hljs-comment">// 决策点：我该如何到达 (i, j) 这个状态？</span><br><br>                <span class="hljs-comment">// 路径1：从 (i-1, j) 走“放走”路线过来</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">exp_let_go</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>                <span class="hljs-keyword">if</span> (dp[i-<span class="hljs-number">1</span>][j] != Long.MIN_VALUE) &#123; <span class="hljs-comment">// 确保起点可达</span><br>                    exp_let_go = dp[i-<span class="hljs-number">1</span>][j] + i;<br>                &#125;<br><br>                <span class="hljs-comment">// 路径2：从 (i-1, j-1) 走“击败”路线过来</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">exp_defeat</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;<br>                <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] != Long.MIN_VALUE) &#123; <span class="hljs-comment">// 确保起点可达，且至少击败了1次</span><br>                    exp_defeat = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + a[i-<span class="hljs-number">1</span>] + (j % <span class="hljs-number">10</span>) * a[i-<span class="hljs-number">1</span>];<br>                &#125;<br>                <br>                <span class="hljs-comment">// 裁判上场！选出到达 (i,j) 的分站冠军分数</span><br>                dp[i][j] = Math.max(exp_let_go, exp_defeat);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 终点线：比较所有终点站的分站冠军，找出全程总冠军</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxResult</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= n; j++) &#123;<br>            maxResult = Math.max(maxResult, dp[n][j]);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxResult;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="探险总结"><a href="#探险总结" class="headerlink" title="探险总结"></a>探险总结</h3><p>这次经历让我明白，学习算法最有效的方式就是不断地追问“为什么”。每一个看似愚蠢的问题，背后都可能隐藏着对核心概念的误解。只有把这些问题都解决了，知识才能真正为你所有。希望我这份详尽的“踩坑”与“顿悟”实录，能对你有所帮助。</p>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
      <tag>Java</tag>
      
      <tag>学习笔记</tag>
      
      <tag>问题求解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法学习笔记：二分查找的两种写法与细节</title>
    <link href="/2025/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2025/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>好的同学，我们来看新的内容：<strong>二分查找</strong>。</p><p>这是一个非常经典且高效的算法，但同时它也是一个“细节是魔鬼”的算法。很多人觉得懂了，但一写就错。你提供的这篇文章，作者“代码随想录”把二分查找的精髓讲得非常透彻。</p><p>他提出了一个核心观点：<strong>写二分查找，最重要的是要搞清楚你定义的区间是“闭”的还是“开”的，然后所有的细节都围绕这个定义来展开，形成统一的逻辑。</strong></p><p>我们来学习文章中提到的两种主要写法。</p><hr><h3 id="写法一：左闭右闭区间-left-right"><a href="#写法一：左闭右闭区间-left-right" class="headerlink" title="写法一：左闭右闭区间 [left, right]"></a>写法一：左闭右闭区间 <code>[left, right]</code></h3><p>这是最常见也最符合我们直觉的一种写法。</p><ol><li><p><strong>区间定义</strong>：我们的查找范围是 <code>[left, right]</code>，这意味着 <code>left</code> 和 <code>right</code> 这两个端点都是可以取到的有效值。</p><ul><li><code>left = 0</code>, <code>right = nums.length - 1</code></li></ul></li><li><p><strong>循环条件</strong>：因为 <code>left</code> 和 <code>right</code> 相等时是有意义的（比如数组只有一个元素 <code>[5]</code>，此时 <code>left=0</code>, <code>right=0</code>，这个区间是有效的），所以循环条件应该是 <code>while (left &lt;= right)</code>。</p></li><li><p>**中间值 <code>mid</code>**：<code>int mid = left + ((right - left) / 2);</code></p><ul><li><em>小提示：这样写是为了防止 <code>left + right</code> 的值过大导致整数溢出，效果等同于 <code>(left + right) / 2</code>，但更稳妥。</em></li></ul></li><li><p><strong>如何移动边界</strong>：这是最关键的细节！</p><ul><li>如果 <code>nums[mid] &gt; target</code>，说明 <code>target</code> 在 <code>mid</code> 的左边。因为我们当前的区间是 <code>[left, right]</code>，所以 <code>target</code> 可能的范围是 <code>[left, mid - 1]</code>。因此，下一步应该是 <code>right = mid - 1</code>。</li><li>如果 <code>nums[mid] &lt; target</code>，说明 <code>target</code> 在 <code>mid</code> 的右边，可能的范围是 <code>[mid + 1, right]</code>。因此，下一步应该是 <code>left = mid + 1</code>。</li><li>如果 <code>nums[mid] == target</code>，恭喜，找到了，直接返回 <code>mid</code> 就行。</li></ul></li></ol><p><strong>总结 <code>[left, right]</code> 写法的要点</strong>：</p><ul><li>循环条件是 <code>while (left &lt;= right)</code>。</li><li>因为 <code>mid</code> 已经被检查过了，所以移动边界时要跳过 <code>mid</code>，即 <code>right = mid - 1</code> 和 <code>left = mid + 1</code>。</li></ul><hr><h3 id="写法二：左闭右开区间-left-right"><a href="#写法二：左闭右开区间-left-right" class="headerlink" title="写法二：左闭右开区间 [left, right)"></a>写法二：左闭右开区间 <code>[left, right)</code></h3><p>这种写法在处理一些边界问题时有奇效，也值得我们掌握。</p><ol><li><p><strong>区间定义</strong>：我们的查找范围是 <code>[left, right)</code>，这意味着 <code>left</code> 可以取到，但 <code>right</code> <strong>不能</strong>取到，它只是一个边界。</p><ul><li><code>left = 0</code>, <code>right = nums.length</code> (注意，这里 <code>right</code> 的初始值和第一种写法不同)</li></ul></li><li><p><strong>循环条件</strong>：因为 <code>left</code> 和 <code>right</code> 相等时，区间 <code>[left, left)</code> 是一个空区间，没有意义，所以循环条件应该是 <code>while (left &lt; right)</code>。当 <code>left == right</code> 时，循环就应该停止。</p></li><li><p>**中间值 <code>mid</code>**：<code>int mid = left + ((right - left) / 2);</code> (计算方法不变)</p></li><li><p><strong>如何移动边界</strong>：</p><ul><li>如果 <code>nums[mid] &gt; target</code>，说明 <code>target</code> 在 <code>mid</code> 的左边。因为我们的右边界 <code>right</code> 是开区间，所以 <code>target</code> 的可能范围是 <code>[left, mid)</code>。因此，下一步应该是 <code>right = mid</code>。</li><li>如果 <code>nums[mid] &lt; target</code>，说明 <code>target</code> 在 <code>mid</code> 的右边，可能的范围是 <code>[mid + 1, right)</code>。因此，下一步应该是 <code>left = mid + 1</code>。</li><li>如果 <code>nums[mid] == target</code>，找到了，直接返回 <code>mid</code>。</li></ul></li></ol><p><strong>总结 <code>[left, right)</code> 写法的要点</strong>：</p><ul><li>循环条件是 <code>while (left &lt; right)</code>。</li><li>移动左边界时，因为 <code>mid</code> 已经检查过了，所以还是 <code>left = mid + 1</code>。</li><li>移动右边界时，因为 <code>right</code> 本身就是取不到的，所以新的右边界可以直接设为 <code>mid</code>，即 <code>right = mid</code>。</li></ul><hr><h3 id="额外需要关注的知识点"><a href="#额外需要关注的知识点" class="headerlink" title="额外需要关注的知识点"></a>额外需要关注的知识点</h3><ol><li><strong>前提条件</strong>：二分查找能使用的<strong>前提</strong>是：<strong>数组有序</strong>，并且数组中<strong>没有重复元素</strong>（如果有重复元素，查找逻辑会更复杂一些</li></ol>]]></content>
    
    
    <categories>
      
      <category>算法笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二分查找</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 最佳实践：为什么推荐使用 &#39;表名. 列名&#39;</title>
    <link href="/2025/10/15/SQL%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%20&#39;%E8%A1%A8%E5%90%8D.%20%E5%88%97%E5%90%8D&#39;/"/>
    <url>/2025/10/15/SQL%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%20&#39;%E8%A1%A8%E5%90%8D.%20%E5%88%97%E5%90%8D&#39;/</url>
    
    <content type="html"><![CDATA[<h3 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h3><p>为什么要把 <code>OrderID</code> 写成 <code>Orders.OrderID</code>？</p><h3 id="直接答案"><a href="#直接答案" class="headerlink" title="直接答案"></a>直接答案</h3><p><strong>为了避免混淆并让代码更清晰，尤其是在多个关联表拥有相同列名时。</strong></p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-避免歧义-最主要的原因-⚠️"><a href="#1-避免歧义-最主要的原因-⚠️" class="headerlink" title="1. 避免歧义 (最主要的原因) ⚠️"></a>1. 避免歧义 (最主要的原因) ⚠️</h4><ul><li><p><strong>问题</strong>: 想象一下，如果 <code>Customers</code> 表和 <code>Orders</code> 表里都有一个叫做 <code>ID</code> 的列。</p><ul><li><code>Customers</code> 表里的 <code>ID</code> 是客户 ID。</li><li><code>Orders</code> 表里的 <code>ID</code> 是订单 ID。</li></ul><p>如果你写 <code>SELECT ID FROM ...</code>，数据库就不知道你到底想要哪个表的 <code>ID</code>。它会立即报错，告诉你 “列名 <code>ID</code> 有歧-义 (ambiguous)”。</p></li><li><p><strong>解决方法</strong>: 通过写 <code>SELECT Customers.ID, Orders.ID FROM ...</code>，你就明确地告诉了数据库你想要的是哪个表里的 <code>ID</code>，歧义就此消失。</p></li></ul><h4 id="2-提高代码可读性-👓"><a href="#2-提高代码可读性-👓" class="headerlink" title="2. 提高代码可读性 👓"></a>2. 提高代码可读性 👓</h4><ul><li>当你或你的同事几个月后再回来看一段复杂的 SQL 查询时，<code>Customers.CustomerName</code> 和 <code>Orders.OrderDate</code> 这样的写法能让读者立刻明白每个数据字段的来源。</li><li>这使得复杂的查询逻辑更容易被理解和后期维护。</li></ul><h4 id="3-这是一个专业的编程习惯-👍"><a href="#3-这是一个专业的编程习惯-👍" class="headerlink" title="3. 这是一个专业的编程习惯 👍"></a>3. 这是一个专业的编程习惯 👍</h4><ul><li>虽然在我们之前的简单例子</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>数据库</tag>
      
      <tag>代码规范</tag>
      
      <tag>最佳实践</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>技术科普：什么是 WAPI 及其优缺点</title>
    <link href="/2025/10/15/WAPI%E4%B8%8EWIFI/"/>
    <url>/2025/10/15/WAPI%E4%B8%8EWIFI/</url>
    
    <content type="html"><![CDATA[<h3 id="核心优缺点摘要"><a href="#核心优缺点摘要" class="headerlink" title="核心优缺点摘要"></a>核心优缺点摘要</h3><blockquote><p><strong>优点:</strong> 安全性高，为无线局域网提供更强的身份认证和数据保密机制，适用于对安全有较高要求的场景。</p><p><strong>缺点:</strong> 对普通用户影响不大，开启和关闭通常感觉不到明显差异，且可能增加设备耗电，因此如果对安全性没有特殊要求，可以选择不开启。</p></blockquote><hr><h3 id="什么是-WAPI？"><a href="#什么是-WAPI？" class="headerlink" title="什么是 WAPI？"></a>什么是 WAPI？</h3><p>WAPI 的全称是 <strong>无线局域网鉴别与保密基础结构</strong> (WLAN Authentication and Privacy Infrastructure)，是中国提出的无线安全标准，旨在提高无线网络（WLAN）的安全性。</p><p>它通过双向认证、更强的加密算法（如 SMS 4）和公钥密码技术，来保护用户身份和数据传输安全。WAPI 是一种独立于 Wi-Fi (802.11) 标准的安全协议，但在硬件上是兼容的，可以通过软件切换来使用。</p><h3 id="主要功能与特点"><a href="#主要功能与特点" class="headerlink" title="主要功能与特点"></a>主要功能与特点</h3><ul><li><p><strong>双向认证</strong><br>与常见的 Wi-Fi 单向认证不同，WAPI 允许终端和接入点（AP）之间相互验证身份，极大地提高了连接的安全性。</p></li><li><p><strong>强大的加密机制</strong><br>使用 SMS 4 等公认的强加密算法，能有效保护数据在无线传输过程中的私密性，防止被窃听和破解。</p></li><li><p><strong>公钥密码技术</strong><br>利用数字证书进行身份认证，确保接入网络的设备和服务器都是合法的，防止“钓鱼”热点或非法接入。</p></li><li><p><strong>包含两种主要协议</strong></p><ul><li><strong>WAI (无线局域网鉴别基础结构)</strong>: 负责身份鉴别和密钥管理。</li><li><strong>WPI (无线局域网保密基础结构)</strong>: 负责数据加密和数据鉴别。</li></ul></li><li><p><strong>中国强制标准</strong><br>WAPI 是中国无线局域网安全强制性标准中的一个核心安全机制。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>WAPI</tag>
      
      <tag>WLAN</tag>
      
      <tag>网络安全</tag>
      
      <tag>Wi-Fi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 核心概念回顾与数据库设计原则</title>
    <link href="/2025/10/14/SQL%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2025/10/14/SQL%20%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>这篇笔记整合了 SQL 的基础查询要点和数据库设计的核心原则——“为什么需要分表”，前者是“如何操作”，后者是“为什么这么设计”。</p><hr><h3 id="第一部分：SQL-基础查询复习提纲"><a href="#第一部分：SQL-基础查询复习提纲" class="headerlink" title="第一部分：SQL 基础查询复习提纲"></a>第一部分：SQL 基础查询复习提纲</h3><h4 id="主题"><a href="#主题" class="headerlink" title="主题:"></a><strong>主题:</strong></h4><ul><li>基本的 SQL 查询 (<code>SELECT</code>, <code>FROM</code>)</li><li>使用 <code>WHERE</code> 进行数据筛选</li><li>使用 <code>ORDER BY</code> 进行结果排序</li><li>聚合函数 (<code>COUNT</code>, <code>SUM</code>, <code>AVG</code>)</li></ul><h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h4><p>本指南涵盖了构成一条基本 SQL 查询的核心要素，包括如何从表中选择数据、如何使用条件进行筛选、如何对结果进行排序，以及如何执行如计数、求和与求平均值等基本计算。指南将特别关注 <code>ORDER BY</code> 子句中排序方向的正确使用，以及 <code>COUNT</code> 和 <code>SUM</code> 等关键聚合函数之间的区别。</p><h4 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念:"></a><strong>关键概念:</strong></h4><ul><li><strong><code>SELECT ... FROM ...</code> 结构</strong>: 这是所有查询的基础。<code>SELECT</code> 用于指定你想查看的<strong>列</strong>，而 <code>FROM</code> 用于指定数据来源的<strong>表</strong>。</li><li><strong><code>WHERE</code> 子句</strong>: 像一个过滤器，它根据你设定的条件筛选出符合要求的<strong>行</strong>。你可以使用 <code>AND</code> 来组合多个必须同时满足的条件。</li><li><strong><code>ORDER BY</code> 子句</strong>: 用于对最终的查询结果进行排序。这是你需要重点复习的部分：<ul><li><code>ASC</code> (Ascending) 表示<strong>升序</strong>（从小到大，A-Z），这是默认的排序方式。</li><li><code>DESC</code> (Descending) 表示<strong>降序</strong>（从大到小，Z-A）。</li></ul></li><li><strong>聚合函数</strong>: 对一组值进行计算，并返回一个单一的汇总结果。理解它们的区别至关重要：<ul><li><code>COUNT()</code>: 用于<strong>计数</strong>，即计算有多少行。</li><li><code>SUM()</code>: 用于<strong>求和</strong>，即计算某一列数值的总和。</li><li><code>AVG()</code>: 用于<strong>求平均值</strong>。</li></ul></li></ul><h4 id="词汇列表"><a href="#词汇列表" class="headerlink" title="词汇列表:"></a><strong>词汇列表:</strong></h4><ul><li><strong>SELECT</strong>: 用于从数据库中选取数据的命令。</li><li><strong>FROM</strong>: 指定数据来源表的子句。</li><li><strong>WHERE</strong>: 用于筛选记录的子句。</li><li><strong>AND</strong>: 一个逻辑运算符，要求所有连接的条件都必须为真。</li><li><strong>ORDER BY</strong>: 用于对结果集进行排序的子句。</li><li><strong>ASC</strong>: 升序排列的缩写。</li><li><strong>DESC</strong>: 降序排列的缩写。</li><li><strong>COUNT()</strong>: 返回行数的聚合函数。</li><li><strong>SUM()</strong>: 返回数值列总和的聚合函数。</li><li><strong>AVG()</strong>: 返回数值列平均值的聚合函数。</li></ul><h4 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题:"></a><strong>关键问题:</strong></h4><ul><li><code>DESC</code> 和 <code>ASC</code> 在 <code>ORDER BY</code> 子句中分别代表什么意思？哪一个是默认的？</li><li>什么时候应该使用 <code>COUNT(*)</code>，什么时候应该使用 <code>SUM(column_name)</code>？请举例说明。</li><li>请尝试编写一条查询：从 <code>Products</code> 表中找出所有价格高于 3.00 的产品，并按产品名称 (<code>ProductName</code>) 的字母倒序排列。</li></ul><hr><h3 id="第二部分：为什么需要分表（避免数据冗余）"><a href="#第二部分：为什么需要分表（避免数据冗余）" class="headerlink" title="第二部分：为什么需要分表（避免数据冗余）"></a>第二部分：为什么需要分表（避免数据冗余）</h3><p>将所有信息都塞进一个大表，在个人使用、数据量小的情况下很方便。但当数据量变大、或者需要多人协作、长期维护时，“大表模式”就会带来三个非常严重的问题，我们称之为“更新异常”、“插入异常”和“删除异常”。</p><p>假设我们把客户和订单信息合并成一个大表，然后客户“张三”又下了一个新订单：</p><p><strong>合并后的大表（不好的设计）:</strong></p><table><thead><tr><th align="left">OrderID</th><th align="left">CustomerID</th><th align="left">CustomerName</th><th align="left">OrderDate</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">101</td><td align="left">张三</td><td align="left">2025-10-12</td></tr><tr><td align="left">2</td><td align="left">102</td><td align="left">李四</td><td align="left">2025-10-13</td></tr><tr><td align="left">3</td><td align="left">101</td><td align="left">张三</td><td align="left">2025-10-14</td></tr><tr><td align="left">4</td><td align="left">101</td><td align="left">张三</td><td align="left">2025-10-15</td></tr></tbody></table><p>你看，<strong>“张三”这个名字被重复存储了3次</strong>。这就是问题的根源。</p><h4 id="1-数据冗余和更新异常-Update-Anomaly"><a href="#1-数据冗余和更新异常-Update-Anomaly" class="headerlink" title="1. 数据冗余和更新异常 (Update Anomaly)"></a><strong>1. 数据冗余和更新异常 (Update Anomaly)</strong></h4><ul><li><strong>问题</strong>: 如果有一天“张三”改名叫“张伟”了。你需要找到<strong>所有</strong>他下过的订单，然后把每一行的 <code>CustomerName</code> 都从“张三”改成“张伟”。如果漏改了一行，数据库里的数据就不一致了，有的订单是“张三”的，有的是“张伟”的，你就搞不清状况了。</li><li><strong>分表如何解决</strong>: 在分表设计中（<code>Customers</code> 表和 <code>Orders</code> 表），你只需要去 <code>Customers</code> 表里，把 <code>CustomerID</code> 为 101 的那<strong>一行</strong>的名字改成“张伟”即可。所有 <code>Orders</code> 表中引用了 <code>CustomerID</code> 101 的订单，都会自动关联到这个新名字上。<strong>只改一处，永久生效</strong>。</li></ul><h4 id="2-插入异常-Insertion-Anomaly"><a href="#2-插入异常-Insertion-Anomaly" class="headerlink" title="2. 插入异常 (Insertion Anomaly)"></a><strong>2. 插入异常 (Insertion Anomaly)</strong></h4><ul><li><strong>问题</strong>: 如果我们想添加一个新客户“王五”，但他还没有下任何订单。在这个大表里，你就没法添加他了。因为 <code>OrderID</code> 和 <code>OrderDate</code> 都是空的，这行数据是不完整的，可能会违反表的设计约束。</li><li><strong>分表如何解决</strong>: 你可以直接在 <code>Customers</code> 表里添加一行 <code>(103, &#39;王五&#39;)</code>，完全没问题。他可以存在于客户列表里，直到他下第一个订单为止。</li></ul><h4 id="3-删除异常-Deletion-Anomaly"><a href="#3-删除异常-Deletion-Anomaly" class="headerlink" title="3. 删除异常 (Deletion Anomaly)"></a><strong>3. 删除异常 (Deletion Anomaly)</strong></h4><ul><li><strong>问题</strong>: 客户“李四”只有一个订单。如果因为某种原因，我们要删除这个订单（比如订单取消了），那么在大表里，我们就得删除 <code>OrderID</code> 为 2 的这一整行。结果是什么？<strong>我们把“李四”这个客户的信息也一起删除了！</strong> 他从我们的系统里消失了。</li><li><strong>分表如何解决</strong>: 你只需要从 <code>Orders</code> 表里删除 <code>OrderID</code> 为 2 的记录。<code>Customers</code> 表完全不受影响，“李四”依然是我们的客户。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>数据库设计</tag>
      
      <tag>数据冗余</tag>
      
      <tag>SELECT</tag>
      
      <tag>WHERE</tag>
      
      <tag>ORDER BY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客 PowerShell 发布完整流程笔记</title>
    <link href="/2025/10/14/Hexo%20%E5%8D%9A%E5%AE%A2%20PowerShell%20%E5%8F%91%E5%B8%83%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/10/14/Hexo%20%E5%8D%9A%E5%AE%A2%20PowerShell%20%E5%8F%91%E5%B8%83%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>记录一下使用 PowerShell 发布 Hexo 博客的完整步骤，作为操作备份，防止遗忘。假设已经安装好了 Node. Js 和 Git 环境。</p><p>整个流程分为三步核心操作：<strong>新建文章 -&gt; 生成静态文件 -&gt; 部署到服务器</strong>。</p><h3 id="第-1-步：启动-PowerShell-并进入博客目录"><a href="#第-1-步：启动-PowerShell-并进入博客目录" class="headerlink" title="第 1 步：启动 PowerShell 并进入博客目录"></a>第 1 步：启动 PowerShell 并进入博客目录</h3><p>首先，你需要打开 PowerShell 终端，并切换到你的 Hexo 博客所在的根文件夹。</p><ol><li>按下 <code>Win + X</code> 键，然后选择 “Windows PowerShell” 或者 “终端”。</li><li>使用 <code>cd</code> 命令进入你的 Hexo 博客文件夹。例如，如果你的博客在 <code>D:\blog</code>：</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">cd</span> D:\blog<br><span class="hljs-literal">---</span><br><br><span class="hljs-comment">### 第 2 步：新建文章</span><br><br>使用 `hexo new` 命令来创建一篇新的博文。文章的标题是必需的参数。<br><br>PowerShell<br><br></code></pre></td></tr></table></figure><p>hexo new “你的文章标题”</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><br>例如，创建一篇名为 <span class="hljs-string">&quot;Hello World&quot;</span> 的文章：<br><br>PowerShell<br><br></code></pre></td></tr></table></figure><p>hexo new “Hello World”</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>执行后，Hexo 会在 `source/_posts` 文件夹里创建一个名为 `你的文章标题.md` 的 Markdown 文件。之后就可以用你喜欢的编辑器（如 VS Code, Sublime Text, Typora 等）打开这个文件开始写作了。<br><br>---<br><br>### 第 <span class="hljs-number">3</span> 步：生成并部署<br><br>在你写完文章并保存之后，就到了发布的环节。这里有两个核心命令 `generate` 和 `deploy`。<br><br>#### 清除缓存并生成静态文件 (`hexo g`)<br><br>这个命令会把你的 Markdown 文章（`.md`）转换成网站所需的静态文件（如 `.html`, `.css`, `.js` 等）。<br><br>PowerShell<br><br></code></pre></td></tr></table></figure><p>hexo clean &amp;&amp; hexo generate</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">- `hexo clean`:</span> 清除之前生成过的旧文件缓存（即 `public` 文件夹），这可以避免一些潜在的缓存问题。<br>    <br><span class="hljs-title">- `hexo generate` (可简写为 `hexo g`):</span> 生成最新的网站文件，默认会存放在 `public` 文件夹里。<br>    <br><span class="hljs-title">- `&amp;&amp;`:</span> 这是一个连接符，表示先执行 `hexo clean` 命令，当它成功执行完毕后，再执行 `hexo generate` 命令。<br>    <br><br>#### 部署到网站 (`hexo d`)<br><br>这个命令会把 `public` 文件夹里的所有内容推送到你在 `_config.yml` 文件里配置好的 Git 仓库（比如 GitHub Pages）。<br><br>PowerShell<br><br></code></pre></td></tr></table></figure><p>hexo deploy</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-bullet">-</span> <span class="hljs-string">`hexo</span> <span class="hljs-string">deploy`</span> <span class="hljs-string">(可简写为</span> <span class="hljs-string">`hexo</span> <span class="hljs-string">d`)</span><br>    <br><span class="hljs-bullet">-</span> <span class="hljs-string">执行此命令时，PowerShell</span> <span class="hljs-string">可能会提示你输入</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">的用户名和密码（或</span> <span class="hljs-string">Personal</span> <span class="hljs-string">Access</span> <span class="hljs-string">Token），根据提示输入即可完成推送。</span><br>    <br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment">### 总结：最常用的命令组合</span><br><br><span class="hljs-string">在你写完文章并保存后，只需要在</span> <span class="hljs-string">PowerShell</span> <span class="hljs-string">的博客根目录里，按顺序执行以下命令即可完成发布：</span><br><br><span class="hljs-string">PowerShell</span><br><br></code></pre></td></tr></table></figure><h1 id="1-新建文章-只需要在开始写作时用一次"><a href="#1-新建文章-只需要在开始写作时用一次" class="headerlink" title="1. 新建文章 (只需要在开始写作时用一次)"></a>1. 新建文章 (只需要在开始写作时用一次)</h1><p>hexo new “My New Post”</p><h1 id="2-写完文章后，一键生成并部署-这是最常用的组合"><a href="#2-写完文章后，一键生成并部署-这是最常用的组合" class="headerlink" title="2. 写完文章后，一键生成并部署 (这是最常用的组合)"></a>2. 写完文章后，一键生成并部署 (这是最常用的组合)</h1><p>hexo g -d</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><br>这里的 `hexo g -d` 是 `hexo <span class="hljs-keyword">generate</span> --deploy` 的缩写，它会先执行生成操作，然后立刻执行部署操作，一步到位，非常方便。<br><br>### 可选步骤：本地预览<br><br>在发布到线上服务器之前，如果你想先在自己电脑上看看网站效果，可以使用本地预览命令：<br><br>PowerShell<br><br></code></pre></td></tr></table></figure><p>hexo server</p><pre><code class="hljs">- `hexo server` (可简写为 `hexo s`)    执行后，PowerShell 会显示一个网址，通常是 `http://localhost:4000`。在浏览器里打开这个网址，就可以实时预览你的博客效果了。确认所有内容显示无误后，在 PowerShell 窗口里按 `Ctrl + C` 停止本地服务器，然后再执行 `hexo g -d` 进行部署。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>PowerShell</tag>
      
      <tag>Git</tag>
      
      <tag>博客部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 学习笔记：用拼图游戏理解 JOIN</title>
    <link href="/2025/10/14/SQL%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%94%A8%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%90%86%E8%A7%A3%20JOIN/"/>
    <url>/2025/10/14/SQL%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%94%A8%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%90%86%E8%A7%A3%20JOIN/</url>
    
    <content type="html"><![CDATA[<h3 id="🧩-把-JOIN-想象成拼图"><a href="#🧩-把-JOIN-想象成拼图" class="headerlink" title="🧩 把 JOIN 想象成拼图"></a>🧩 把 JOIN 想象成拼图</h3><p>忘掉代码，我们来玩个游戏。</p><p>你有<strong>两盒拼图块</strong>：</p><p><strong>盒子 A (客户表 <code>Customers</code>)</strong></p><ul><li>每一块拼图上都有一个 <strong>客户 ID</strong> 和一个 <strong>客户名字</strong>。<ul><li><code>[ID: 101 | 名字: 张三]</code></li><li><code>[ID: 102 | 名字: 李四]</code></li></ul></li></ul><p><strong>盒子 B (订单表 <code>Orders</code>)</strong></p><ul><li>每一块拼图上都有一个 <strong>订单号</strong> 和一个 <strong>客户 ID</strong>。<ul><li><code>[订单号: 1 | ID: 101]</code></li><li><code>[订单号: 2 | ID: 102]</code></li><li><code>[订单号: 3 | ID: 101]</code></li></ul></li></ul><hr><h3 id="🎯-我们的目标"><a href="#🎯-我们的目标" class="headerlink" title="🎯 我们的目标"></a>🎯 我们的目标</h3><p>我们想知道<strong>每个订单号</strong>对应的<strong>客户名字</strong>是谁。</p><p>但是，<code>订单号</code> 在 <strong>B 盒</strong>，<code>客户名字</code> 在 <strong>A 盒</strong>。信息是分开的。</p><p><code>JOIN</code> 就是那个帮你**把能匹配的拼图块拼在一起</p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>JOIN</tag>
      
      <tag>数据库</tag>
      
      <tag>入门教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排错实录：端口443如何解决SSH连接超时问题</title>
    <link href="/2025/09/08/%E7%AB%AF%E5%8F%A3443%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3SSH%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2025/09/08/%E7%AB%AF%E5%8F%A3443%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3SSH%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一、遇到的问题：神秘的网络连接失败"><a href="#一、遇到的问题：神秘的网络连接失败" class="headerlink" title="一、遇到的问题：神秘的网络连接失败"></a>一、遇到的问题：神秘的网络连接失败</h3><p>今天，在我搭建和部署个人博客的过程中，我遇到了一个极其令人困惑的问题。当我满怀信心地在 PowerShell 中运行 <code>hexo deploy</code> 命令时，终端却无情地返回了网络错误：<br>ssh: connect to host github.com port 22: Connection timed out</p><p>最奇怪的是，我明明可以正常地用浏览器打开 GitHub 网站，登录、浏览都没有任何问题。为什么我的浏览器可以连接，而我的 PowerShell 却不行呢？这成了我今天需要解开的谜题。</p><h3 id="二、探寻真相：网页浏览和-SSH-连接有何不同？"><a href="#二、探寻真相：网页浏览和-SSH-连接有何不同？" class="headerlink" title="二、探寻真相：网页浏览和 SSH 连接有何不同？"></a>二、探寻真相：网页浏览和 SSH 连接有何不同？</h3><p>经过一番探索，我终于明白了问题的核心：<strong>能浏览网页，不代表所有开发工具都能正常联网。</strong></p><p>我们可以用一个“访问一栋安全大厦”的比喻来理解：</p><ul><li><strong>GitHub 服务器</strong>：就像一栋安保严密的大厦。</li><li>**网络端口 (Port)**：就是进入大厦的不同“门”。</li><li><strong>我的网络环境（防火墙）</strong>：就是大厦门口的“保安”。</li></ul><p>What is the Significance of Changing to Port 443?<br>改为443端口有什么意义？<br>The simple significance is that you are disguising your specialized traffic as common web traffic to bypass firewalls.<br>简单的意义是，您将专用流量伪装成常见的 Web 流量以绕过防火墙 。</p><p>To understand this, think of a server like GitHub as a large, secure building, and ports as the different doors into that building.<br>要理解这一点，请将像 GitHub 这样的服务器视为一个大型、安全的建筑物，而端口则是进入该建筑物的不同门。</p><p>Door #22 (The Default SSH Port): This is like a special, high-security employee-only entrance in the back of the building. It’s very efficient and secure, but for that very reason, many public places (like cafés, airports, or even strict home networks) keep this door locked and sealed (the firewall blocks port 22). When you tried to connect, you found this door was locked (Connection timed out).<br>门 #22（默认 SSH 端口）： 这就像大楼后面一个特殊的、高度安全的员工专用入口 。它非常高效和安全，但正是出于这个原因，许多公共场所（如咖啡馆、机场，甚至严格的家庭网络）都将这扇门锁上并密封（防火墙阻止了端口 22）。当您尝试连接时，您发现此门已锁定（ 连接超时 ）。</p><p>Door #443 (The HTTPS Port): This is the main public entrance to the building. It has a big “Welcome” sign and is used by millions of people every minute for secure web browsing (when you see https:&#x2F;&#x2F; in your browser). Because this door must be open for the internet to function, it is almost never blocked by any firewall.<br>门 #443（HTTPS 端口）： 这是大楼的主要公共入口 。它有一个很大的“欢迎”标志，每分钟有数百万人使用它来进行安全的网页浏览（当您在浏览器中看到 https:&#x2F;&#x2F; 时）。因为这扇门必须打开才能使互联网正常运行，所以它几乎从未被任何防火墙阻止 。</p><p>By creating the config file, you essentially told your computer: “Don’t bother trying the locked employee door (#22) anymore. Just go to the main public entrance (#443) and use your employee keycard there.”<br>通过创建配置文件 ，您实际上告诉您的计算机：“不要再费心尝试上锁的员工门 （#22）。只需前往主公共入口 （#443） 并在那里使用您的员工钥匙卡即可。</p><p>Is This Important for Programmers?<br>这对程序员来说重要吗？<br>Yes, absolutely. Understanding this concept is very important for a programmer. Here’s why:<br>是的，一点没错。理解这个概念对于程序员来说非常重要。 原因如下：</p><p>Real-World Environments: Programmers don’t always work on perfect, unrestricted networks. You will often find yourself working from a corporate office, a university, a client’s site, or a public Wi-Fi hotspot. All of these environments are likely to have firewalls that block standard developer ports like 22.<br>真实环境： 程序员并不总是在完美、不受限制的网络上工作。您经常会发现自己在公司办公室、大学、客户网站或公共 Wi-Fi 热点工作。所有这些环境都可能具有阻止标准开发人员端口（如 22）的防火墙。</p><p>Problem-Solving Ability: Knowing how to diagnose a blocked port and apply this workaround (tunneling over port 443) is a crucial real-world problem-solving skill. It can be the difference between being able to work and being completely stuck.<br>解决问题的能力： 了解如何诊断被阻止的端口并应用此解决方法（通过端口 443 进行隧道传输）是一项至关重要的实际问题解决技能。这可能是能够工作和完全陷入困境之间的区别。</p><p>Understanding the Full Picture: It shows an understanding that programming isn’t just about writing code. It’s also about understanding the networks and systems your code interacts with. Knowing how to navigate network restrictions is a mark of a practical and experienced developer.<br>了解全貌： 它表明了一种理解，即编程不仅仅是编写代码。它还涉及了解您的代码与之交互的网络和系统。知道如何应对网络限制是实用且经验丰富的开发人员的标志。</p><p>You just learned a valuable lesson that many programmers learn the hard way: your tools are only as good as your connection. Knowing how to make your tools work in a difficult network environment is a very important and practical skill that will serve you well in the future.<br>您刚刚学到了一个宝贵的教训，许多程序员都经历了艰难的教训： 您的工具的好坏取决于您的连接。 知道如何让您的工具在困难的网络环境中工作是一项非常重要且实用的技能，将来将为您服务。</p><h4 id="1-为什么浏览器能访问？"><a href="#1-为什么浏览器能访问？" class="headerlink" title="1. 为什么浏览器能访问？"></a>1. 为什么浏览器能访问？</h4><p>当我用浏览器访问 <code>https://github.com</code> 时，我走的是 **443 号门 (HTTPS 端口)**。这是大厦的“正门”，访客络绎不绝，所以保安（防火墙）默认这个门是安全且必须保持开放的，于是挥手放行。</p><h4 id="2-为什么-SSH-会失败？"><a href="#2-为什么-SSH-会失败？" class="headerlink" title="2. 为什么 SSH 会失败？"></a>2. 为什么 SSH 会失败？</h4><p>当我用 <code>hexo deploy</code> 或 <code>ssh</code> 命令时，程序默认尝试走的是 **22 号门 (SSH 端口)**。这像是大厦一个偏僻的“员工专用通道”。很多网络环境的保安（防火墙）为了安全，会把这个不常用的门锁死。我的请求根本到不了门口，自然就“连接超时”了。</p><h3 id="三、解决方案：让-SSH-“伪装”成浏览器流量"><a href="#三、解决方案：让-SSH-“伪装”成浏览器流量" class="headerlink" title="三、解决方案：让 SSH “伪装”成浏览器流量"></a>三、解决方案：让 SSH “伪装”成浏览器流量</h3><p>既然“员工通道”被锁了，那我能不能拿着我的员工卡（SSH 密钥）去走“正门”呢？答案是可以的！</p><p>解决方案就是修改我电脑上的 SSH 客户端配置，告诉它在连接 GitHub 的时候，不要走 22 号门，而是去走那个永远开放的 443 号门。</p><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol><li><p><strong>找到或创建 SSH 配置文件</strong>：在 PowerShell 中用 <code>notepad ~/.ssh/config</code> 命令，在我的用户目录下创建了一个 <code>config</code> 文件。</p></li><li><p><strong>写入“绕路”规则</strong>：在 <code>config</code> 文件里，我粘贴了以下内容：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host github.com<br>  Hostname ssh.github.com<br>  Port <span class="hljs-number">443</span><br>  <span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br></code></pre></td></tr></table></figure><p>这个配置的意思是：“嘿，SSH客户端！下次要去 <code>github.com</code> 的时候，请改道去 <code>ssh.github.com</code> 这个地址，并且走 <code>443</code> 号门。”</p></li><li><p><strong>测试连接</strong>：保存文件后，我运行了测试命令 <code>ssh -T git@github.com</code>。</p><p>这一次，我没有再看到连接超时的错误，而是收到了来自 GitHub 的欢迎信息！</p><blockquote><p>Hi Link22233! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote></li></ol><h3 id="四、经验与教训"><a href="#四、经验与教训" class="headerlink" title="四、经验与教训"></a>四、经验与教训</h3><p>这次排错经历让我学到了非常重要的一课：</p><blockquote><p><strong>网络连接问题是分层且具体的。</strong> 不能简单地用“能上网”来判断连接性。</p></blockquote><p>一个程序的网络请求能否成功，取决于它的<strong>协议、目标地址和端口</strong>，以及这条路径上每一道“安检”（防火墙）的规则。</p><p>对于程序员来说，理解网络端口的基本概念，并掌握像修改 SSH 端口这样绕过网络限制的技巧，是一项非常实用且重要的能力。它能帮助我们在各种复杂的网络环境中保持生产力，而不是被一个简单的“连接超时”困住。</p><p>最终，这个小小的 <code>config</code> 文件，解决了困扰我许久的部署难题，也让我对网络问题的排查有了更深刻的理解。</p>]]></content>
    
    
    <categories>
      
      <category>技术排错</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Git</tag>
      
      <tag>网络问题</tag>
      
      <tag>SSH</tag>
      
      <tag>防火墙</tag>
      
      <tag>端口443</tag>
      
      <tag>端口20</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程学习笔记：代码调试 (Debugging) 的核心方法与技巧</title>
    <link href="/2025/09/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%20(Debugging)%20%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/09/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%20(Debugging)%20%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="第一部分：核心思想——你和计算机的“误会”"><a href="#第一部分：核心思想——你和计算机的“误会”" class="headerlink" title="第一部分：核心思想——你和计算机的“误会”"></a><strong>第一部分：核心思想——你和计算机的“误会”</strong></h3><p>在你开始学习具体的技巧之前，一定要先理解这篇文章的核心思想，这非常非常重要：</p><blockquote><p><strong>当程序没有按你的预期运行时，几乎总是因为你对代码的理解和计算机实际执行的情况之间存在“误会”。代码永远是忠实地执行你写下的指令，而不是你脑子里想的那个指令。</strong></p></blockquote><p>Debug的过程，其实就是通过各种方法，去<strong>看清楚代码实际上是怎么一步一步执行的</strong>，从而找到你和计算机之间的那个“误会”到底在哪里。</p><hr><h3 id="第二部分：Debug-的四种层次"><a href="#第二部分：Debug-的四种层次" class="headerlink" title="第二部分：Debug 的四种层次"></a><strong>第二部分：Debug 的四种层次</strong></h3><p>文章提到了四种从易到难的 Debug 方法，帮你建立一个完整的概念：</p><ol><li><p><strong>直接读代码（人肉 Debug）</strong>：这是最基本的方法，通过一遍一遍地读代码，试图在脑子里模拟程序的运行，找出逻辑漏洞。对于初学者来说，这可能比较困难。</p></li><li><p><strong>求助 AI 工具</strong>：像 ChatGPT 这样的工具很强大，可以直接把有问题的代码丢给它，让它帮你找 bug 或者提供思路。这是一个很现代、很高效的方法。</p></li><li><p><strong>打印日志（打点观察）</strong>：<strong>这是我们这节课的重点！</strong> 通过在代码的关键位置插入打印语句（比如 <code>System.out.println</code>），输出变量的值或者程序的执行路径。这个方法虽然看起来“笨”，但极其有效。</p></li><li><p><strong>使用 IDE 的断点调试</strong>：这是最专业、最强大的方法，你可以在代码的任何地方设置一个“断点”，让程序运行到那里就暂停，然后你可以检查所有变量的状态，再单步执行。</p></li></ol><p>这篇教程的重点，就是教你如何精通第3种方法——<strong>“打印日志”</strong>，因为它能帮你深刻理解代码的执行流程。</p><hr><h3 id="第三部分：核心技巧——如何通过“打印”来破案"><a href="#第三部分：核心技巧——如何通过“打印”来破案" class="headerlink" title="第三部分：核心技巧——如何通过“打印”来破案"></a><strong>第三部分：核心技巧——如何通过“打印”来破案</strong></h3><p>接下来，我们来看文章里的几个关键案例，学习在不同场景下应该在哪里“打印”，打印什么内容。</p><h4 id="案例一：循环-for-循环"><a href="#案例一：循环-for-循环" class="headerlink" title="案例一：循环 (for 循环)"></a><strong>案例一：循环 (<code>for</code> 循环)</strong></h4><ul><li><p><strong>问题</strong>：循环的结果不对，不知道是循环次数错了，还是里面的计算错了。</p></li><li><p><strong>解决方法</strong>：在 <code>for</code> 循环<strong>内部</strong>打印出每一轮循环中，你最关心的那个变量的值。</p><p>  Java</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// for循环内部出现问题建议</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-comment">// 核心逻辑</span><br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;在第 &quot;</span> + i + <span class="hljs-string">&quot; 次循环时，变量X的值是: &quot;</span> + x); <span class="hljs-comment">// &lt;-- 在这里打印</span><br>&#125;<br>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;循环结束&quot;</span>); <span class="hljs-comment">// &lt;-- 在循环外打印，确认循环是否正常结束</span><br></code></pre></td></tr></table></figure></li><li><p><strong>学习要点</strong>：通过在循环体内打印，你可以清晰地看到每一次迭代中变量的变化过程，一下子就能定位到是哪一轮出了问题。</p></li></ul><h4 id="案例二：链表或-while-循环"><a href="#案例二：链表或-while-循环" class="headerlink" title="案例二：链表或 while 循环"></a><strong>案例二：链表或 <code>while</code> 循环</strong></h4><ul><li><p><strong>问题</strong>：处理链表时，指针飞了，或者循环没有在预期的位置停下来。</p></li><li><p><strong>解决方法</strong>：在 <code>while</code> 循环<strong>内部</strong>，打印出当前节点的值，甚至下一个节点的值。</p><p>  Java</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">while</span> (list != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// 核心操作</span><br>    System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;当前节点值: &quot;</span> + list.val + <span class="hljs-string">&quot; | 下一个节点是: &quot;</span> + list.<span class="hljs-keyword">next</span>); <span class="hljs-comment">// &lt;-- 打印关键信息</span><br>    list = list.<span class="hljs-keyword">next</span>;<br>&#125;<br>System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">&quot;循环结束后，list的值是: &quot;</span> + list); <span class="hljs-comment">// &lt;-- 检查结束时的状态</span><br></code></pre></td></tr></table></figure></li><li><p><strong>学习要点</strong>：对于链表、树这类数据结构，最重要的是观察“指针”或“引用”的变化。打印它们可以帮你追踪整个遍历过程。<br>  想象一下，<code>list</code> 这个变量不是一个普通变量，而是一个<strong>聚光灯</strong>。它的任务就是照亮链表中的某一个节点。</p></li></ul><p><code>list = list.next;</code> 这行代码的作用就是，把聚光灯从<strong>当前照亮的节点</strong>，移动到<strong>下一个节点</strong>去。</p><p><strong>那么，“指针飞了”是什么意思？</strong></p><p>就是这个聚光灯突然不听你指挥了！可能它照着照着，突然“唰”一下跳到了一个很远的、错误的节点上，或者“啪”一下熄灭了（变成了 <code>null</code>），而此时它后面明明还有很多节点没照亮。</p><p><strong>为什么 <code>println</code> 那么好用？</strong></p><p><code>System.out.println(&quot;当前节点值: &quot; + list.val + &quot; | 下一个节点是: &quot; + list.next);</code></p><p>这行代码就像是给聚光灯装了一个“状态播报器”。在聚光灯<strong>移动之前</strong>，它会大声喊出两件事：</p><ol><li><p><strong><code>&quot;当前节点值: &quot; + list.val</code></strong>: “报告！我现在正照着值为 <code>[val]</code> 的节点！” —— 这让你确定聚光灯当前的位置是正确的。</p></li><li><p><strong><code>&quot;下一个节点是: &quot; + list.next</code></strong>: “报告！我下一步准备移动到 <code>[next]</code> 这个位置去！” —— <strong>这才是关键！</strong> 它让你提前看到了聚光灯的<strong>移动目标</strong>。</p></li></ol><p><strong>举个例子：</strong> 假设你期望的输出是 <code>1 -&gt; 2 -&gt; 3</code>。</p><ul><li><p>当聚光灯照着 <code>1</code> 时，它播报：“我现在照着 1，下一步要去 2”。 <strong>（正常）</strong></p></li><li><p>然后聚光灯移动，照着 <code>2</code>，它播报：“我现在照着 2，下一步要去 3”。 <strong>（正常）</strong></p></li><li><p>突然，聚光灯照着 <code>3</code>，它播报：“我现在照着 3，下一步要去 null”。 <strong>（正常，到达终点）</strong></p></li></ul><p>但如果，照着 <code>2</code> 的时候，它突然播报：“我现在照着 2，下一步要去 null”。 你一下子就抓到问题了！根本不需要等到循环结束，你就知道在节点 <code>2</code> 这里，它的 <code>next</code> 指针出错了，导致链表“断”了。</p><p>这就是为什么这行 <code>println</code> 能帮你“预判”错误，抓住那个让聚光灯“飞了”的瞬间。</p><h4 id="案例三：条件判断-if-语句"><a href="#案例三：条件判断-if-语句" class="headerlink" title="案例三：条件判断 (if 语句)"></a><strong>案例三：条件判断 (<code>if</code> 语句)</strong></h4><ul><li><p><strong>问题</strong>：不确定程序到底有没有进入 <code>if</code> 的分支。</p></li><li><p><strong>解决方法</strong>：在 <code>if</code> 代码块<strong>内部</strong>放一个打印语句。</p><p>  Java</p>  <figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">if</span> (condition) &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;程序成功进入了这个 if 分支&quot;</span>); <span class="hljs-comment">// &lt;-- 打印一个标记</span><br>    <span class="hljs-comment">// 核心逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>学习要点</strong>：如果你的控制台打印出了这句话，就证明条件判断为真，代码进来了。如果没打印，那就说明是 <code>condition</code> 本身出了问题。</p></li></ul><h4 id="案例四：递归"><a href="#案例四：递归" class="headerlink" title="案例四：递归"></a><strong>案例四：递归</strong></h4><ul><li><p><strong>问题</strong>：递归太抽象，不知道函数是怎么一层一层调用，又怎么一层一层返回的。</p></li><li><p><strong>解决方法</strong>：在递归函数的<strong>开头</strong>（进入下一层前）和<strong>结尾</strong>（返回上一层后）分别打印信息。</p><p>  Java</p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">void recursiveFunction(Node root) &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br><br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;进入节点: &quot;</span> + root.<span class="hljs-keyword">val</span>); <span class="hljs-comment">// &lt;-- 递归调用前打印（前序遍历位置）</span><br><br>    recursiveFunction(root.left); <span class="hljs-comment">// 递归调用</span><br><br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;离开节点: &quot;</span> + root.<span class="hljs-keyword">val</span>); <span class="hljs-comment">// &lt;-- 递归调用后打印（后序遍历位置）</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>学习要点</strong>：通过这种方式，你可以清晰地看到递归的“深入”和“回溯”过程，这对于理解递归的执行顺序至关重要。</p></li></ul><h3 id="案例四：递归和“进入-离开”-我们用“迷宫探险家”来理解"><a href="#案例四：递归和“进入-离开”-我们用“迷宫探险家”来理解" class="headerlink" title=". 案例四：递归和“进入&#x2F;离开” (我们用“迷宫探险家”来理解)"></a><strong>. 案例四：递归和“进入&#x2F;离开” (我们用“迷宫探险家”来理解)</strong></h3><p>想象一棵树是一个复杂的迷宫，而你的递归函数 <code>recursiveFunction</code> 就是一个<strong>探险家</strong>。</p><ul><li><p><strong><code>System.out.println(&quot;进入节点: &quot; + root.val);</code></strong> 这相当于探险家每到达迷宫中的一个<strong>新路口</strong>（一个节点），他就会用对讲机向你报告：“<strong>报告！我已到达 [val] 号路口！</strong>” 这个报告发生在他<strong>决定要继续深入探索</strong>（比如先走左边通道）<strong>之前</strong>。</p></li><li><p><strong><code>recursiveFunction(root.left);</code></strong> 这是探险家接到的指令：“从当前路口，进入左边的通道，把左边所有通道都走一遍。”</p></li><li><p><strong><code>System.out.println(&quot;离开节点: &quot; + root.val);</code></strong> 这相当于探险家<strong>已经把左边所有通道（以及分支、死路）全部探索完毕，并且回到了</strong>当前这个路口<strong>时</strong>，他再次用对讲机向你报告：“<strong>报告！我已经把 [val] 号路口的左边区域全部探索完毕，现在返回到了 [val] 号路口！</strong>”</p></li></ul><p><strong>把这些报告连起来看，会发生什么？</strong></p><p>假设树是这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">A</span><br> / \<br><span class="hljs-selector-tag">B</span>   C<br></code></pre></td></tr></table></figure><p>你的控制台会打印出这样的日志：</p><ol><li><p>进入节点: A <em>(探险家到达 A)</em></p></li><li><p>进入节点: B <em>(他从 A 进入左边，到达 B)</em></p></li><li><p>离开节点: B <em>(B 的左右都没路了，他探索完 B，返回 A)</em></p></li><li><p>进入节点: C <em>(他回到 A 后，接到指令，进入右边，到达 C)</em></p></li><li><p>离开节点: C <em>(C 探索完毕，返回 A)</em></p></li><li><p>离开节点: A <em>(A 的左右两边都探索完毕了，他彻底离开 A)</em></p></li></ol><h2 id="看到了吗？通过“进入”和“离开”的配对打印，你就能完美地追踪出探险家在迷宫里的完整足迹，清清楚楚地看到他是如何深入，又是如何一步步返回（回溯）的。这就是理解递归执行顺序的关键。"><a href="#看到了吗？通过“进入”和“离开”的配对打印，你就能完美地追踪出探险家在迷宫里的完整足迹，清清楚楚地看到他是如何深入，又是如何一步步返回（回溯）的。这就是理解递归执行顺序的关键。" class="headerlink" title="看到了吗？通过“进入”和“离开”的配对打印，你就能完美地追踪出探险家在迷宫里的完整足迹，清清楚楚地看到他是如何深入，又是如何一步步返回（回溯）的。这就是理解递归执行顺序的关键。"></a>看到了吗？通过“进入”和“离开”的配对打印，你就能<strong>完美地追踪</strong>出探险家在迷宫里的完整足迹，清清楚楚地看到他是如何深入，又是如何一步步<strong>返回（回溯）</strong>的。这就是理解递归执行顺序的关键。</h2><h3 id="总结：这节课你学到了什么？"><a href="#总结：这节课你学到了什么？" class="headerlink" title="总结：这节课你学到了什么？"></a><strong>总结：这节课你学到了什么？</strong></h3><ol><li><p><strong>端正心态</strong>：Debug 不是和计算机吵架，而是去理解它到底是怎么执行你的代码的。</p></li><li><p><strong>掌握核心武器</strong>：学会使用 <code>System.out.println()</code> 这种最简单直接的方法来观察程序的内部状态。</p></li><li><p><strong>培养“盘感”</strong>：这种“笨办法”用多了，你对代码的执行流程会越来越敏感，慢慢地就能培养出一种直觉，以后看代码就能猜到哪里容易出错了。</p></li></ol><p>我们这堂课就来学习一下这个强大的功能。我们把它称为**断点调试 (Breakpoint Debugging)**。</p><hr><h3 id="核心概念：让程序“暂停”，让你“检查”"><a href="#核心概念：让程序“暂停”，让你“检查”" class="headerlink" title="核心概念：让程序“暂停”，让你“检查”"></a><strong>核心概念：让程序“暂停”，让你“检查”</strong></h3><p>想象一下，<code>println</code> 就像是在程序运行时，让变量自己大声喊出它的值。而断点调试，则更像是你拥有了<strong>“时间暂停”</strong>的超能力。</p><p>你可以在代码的任何一行设置一个“暂停点”（也就是<strong>断点</strong>），当程序运行到这里时，它会立刻“冻结”，然后IDE会把当前程序的所有状态，包括所有变量的值，都清清楚楚地展示给你。</p><hr><h3 id="如何操作：三步学会断点调试"><a href="#如何操作：三步学会断点调试" class="headerlink" title="如何操作：三步学会断点调试"></a><strong>如何操作：三步学会断点调试</strong></h3><p>在 VS 或 VS Code 里操作起来非常直观，主要就这几个步骤：</p><h4 id="第一步：设置断点-Set-a-Breakpoint"><a href="#第一步：设置断点-Set-a-Breakpoint" class="headerlink" title="第一步：设置断点 (Set a Breakpoint)"></a><strong>第一步：设置断点 (Set a Breakpoint)</strong></h4><p>在你想要程序暂停的那一行代码旁边，行号的左边，用鼠标<strong>点击一下</strong>。通常会出现一个<strong>红色的圆点</strong>。这就代表你在这里设置了一个断点。</p><ul><li><strong>什么时候设？</strong> 通常设在你怀疑有问题的代码行，或者是一个循环的开始、一个关键的 <code>if</code> 判断之前。</li></ul><h4 id="第二步：启动调试模式-Start-Debugging"><a href="#第二步：启动调试模式-Start-Debugging" class="headerlink" title="第二步：启动调试模式 (Start Debugging)"></a><strong>第二步：启动调试模式 (Start Debugging)</strong></h4><p>这一步很关键！你<strong>不能</strong>用平常的“运行”按钮。你需要找到并点击那个带有<strong>“虫子”图标 🐞</strong> 或者明确写着<strong>“调试” (Debug)</strong> 的启动按钮。</p><ul><li><p>在大多数 IDE 中，快捷键是 <code>F5</code>。</p></li><li><p>程序会开始运行，然后在它遇到的第一个断点处自动暂停。</p></li></ul><h4 id="第三步：观察变量并控制程序"><a href="#第三步：观察变量并控制程序" class="headerlink" title="第三步：观察变量并控制程序"></a><strong>第三步：观察变量并控制程序</strong></h4><p>一旦程序在断点处暂停，IDE 的界面会发生一些变化，通常会弹出几个新窗口，让你大显身手：</p><ol><li><p><strong>观察变量的值 (Inspecting Variables):</strong></p><ul><li><p><strong>变量窗口 (Variables Panel):</strong> 在左侧的调试面板中，会有一个“变量”区域，它会自动列出当前作用域内所有变量的实时值。你可以一层层展开对象或数组，查看里面的具体内容。</p></li><li><p><strong>鼠标悬停 (Hover):</strong> 这是最快的方法！直接在你的代码编辑器里，把鼠标光标移动到任何一个变量名上，稍等片刻，它的当前值就会弹出来。</p></li><li><p><strong>监视窗口 (Watch Panel):</strong> 你还可以把一些你特别关心的变量（甚至是一个表达式，比如 <code>a + b</code>）添加到“监视”窗口，这样无论程序走到哪里，只要这个变量存在，它的值都会被重点监控。</p></li></ul></li><li><p><strong>控制程序的执行流程 (Controlling the Flow):</strong> 在程序暂停时，调试工具栏上会出现几个像播放器一样的按钮，它们是你的“遥控器”：</p><ul><li><p><strong>继续 (Continue &#x2F; <code>F5</code>)</strong>: 让程序继续运行，直到遇到下一个断点或者程序结束。</p></li><li><p><strong>单步跳过 (Step Over &#x2F; <code>F10</code>)</strong>: 执行当前这一行代码，然后停在<strong>下一行</strong>。如果当前行是一个函数调用，它会执行完整个函数，但<strong>不会</strong>进入函数内部。</p></li><li><p><strong>单步调试 (Step Into &#x2F; <code>F11</code>)</strong>: 执行当前这一行。如果这一行是一个函数调用，它会<strong>进入</strong>到那个函数的内部，并停在函数的第一行。这对于追踪一个函数内部的问题非常有用。</p></li><li><p><strong>单步跳出 (Step Out &#x2F; <code>Shift+F11</code>)</strong>: 如果你已经进入了一个函数，这个按钮会执行完这个函数剩下的所有代码，然后返回到调用它的地方。</p></li></ul></li></ol><hr><h3 id="总结：println-vs-断点调试"><a href="#总结：println-vs-断点调试" class="headerlink" title="总结：println vs. 断点调试"></a><strong>总结：<code>println</code> vs. 断点调试</strong></h3><p>现在你已经学会了两种强大的 Debug 方法，那应该在什么时候用哪个呢？</p><ul><li><p><strong>用 <code>println</code> 的场景:</strong></p><ul><li><p>问题比较简单，只想快速验证一个变量的值。</p></li><li><p>在一些不支持断点调试的环境中（比如某些服务器日志）。</p></li><li><p>调试和时间相关或者多线程的问题时，因为断点会让程序暂停，可能会改变问题的表现。</p></li></ul></li><li><p><strong>用断点调试的场景:</strong></p><ul><li><p><strong>绝大多数情况！</strong> 尤其是问题比较复杂，涉及很多变量和函数调用时。</p></li><li><p>当你想理解一段陌生代码的完整执行流程时。</p></li><li><p>当你需要检查大型对象或复杂数据结构的内容时。</p></li></ul></li></ul><p><strong>掌握 IDE 的断点调试功能，是每一个程序员从入门到专业的必经之路。</strong> 它的强大之处在于，它让你能真正地“看”到代码在执行，而不是靠“猜”。<br>当你调试的变量是一个链表或者一棵树时，IDE 的调试器会展现出它真正强大的地方。它<strong>不会</strong>只给你显示一个毫无意义的内存地址。</p><p>简单来说：<strong>调试器会用一个可以“展开”和“折叠”的视图，完美地把链表或树的结构给你呈现出来。</strong></p><p>我们来分别看一下这两种情况。</p><hr><h3 id="情况一：当变量是一个链表-Linked-List"><a href="#情况一：当变量是一个链表-Linked-List" class="headerlink" title="情况一：当变量是一个链表 (Linked List)"></a><strong>情况一：当变量是一个链表 (Linked List)</strong></h3><p>假设你有一个链表，你在代码里有一个指向链表头部的变量，比如叫 <code>head</code>。当你在断点处停下来时，你会这样做：</p><ol><li><p><strong>找到头节点</strong>：在调试器的“变量”窗口里，你会找到 <code>head</code> 这个变量。它旁边会有一个小小的三角形 <code>▶</code> 或者加号 <code>+</code>。</p></li><li><p><strong>展开第一个节点</strong>：你点击那个小三角形，<code>head</code> 变量就会被展开。你会看到这个节点内部的成员，比如它的值 <code>val</code> 和指向下一个节点的指针 <code>next</code>。</p></li><li><p><strong>顺藤摸瓜，查看下一个节点</strong>：现在，最神奇的地方来了！那个 <code>next</code> 指针本身也是一个可以展开的对象。你继续点击 <code>next</code> 旁边的 <code>▶</code>，调试器就会为你展示<strong>第二个节点</strong>的内容（它的 <code>val</code> 和它的 <code>next</code>）。</p></li><li><p><strong>一步步“走”完整个链表</strong>：你可以像这样，一层一层地点开 <code>next</code> -&gt; <code>next</code> -&gt; <code>next</code>… 就好像亲手把这个链条一环一环地解开一样。</p></li></ol><p>这个过程看起来会是这样：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">▼ <span class="hljs-params">head:</span> ListNode (object)<br>  |-- <span class="hljs-params">val:</span> <span class="hljs-number">1</span><br>  ▼ <span class="hljs-params">next:</span> ListNode (object)<br>    |-- <span class="hljs-params">val:</span> <span class="hljs-number">2</span><br>    ▼ <span class="hljs-params">next:</span> ListNode (object)<br>      |-- <span class="hljs-params">val:</span> <span class="hljs-number">3</span><br>      |-- <span class="hljs-params">next:</span> <span class="hljs-literal">null</span>  <span class="hljs-operator">&lt;</span><span class="hljs-operator">-</span>- 你会清晰地看到链表的末尾！<br></code></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><p><strong>结构清晰</strong>：你能直观地看到节点是如何一个接一个连接起来的。</p></li><li><p><strong>轻松发现断链</strong>：如果某个节点的 <code>next</code> 意外地变成了 <code>null</code>，或者指向了一个错误的节点，你会立刻发现。</p></li><li><p><strong>识别循环链表</strong>：如果你不停地展开 <code>next</code>，发现又回到了之前的某个节点，那你就找到了一个环！</p></li></ul><hr><h3 id="情况二：当变量是一棵树-Tree"><a href="#情况二：当变量是一棵树-Tree" class="headerlink" title="情况二：当变量是一棵树 (Tree)"></a><strong>情况二：当变量是一棵树 (Tree)</strong></h3><p>调试树的逻辑和链表非常类似，只不过从“一维”的链条变成了“二维”的结构。</p><p>假设你有一个指向树根的变量 <code>root</code>。</p><ol><li><p><strong>找到根节点</strong>：在“变量”窗口里找到 <code>root</code> 变量。</p></li><li><p><strong>展开根节点</strong>：点击 <code>root</code> 旁边的 <code>▶</code>，你会看到根节点的值 <code>val</code>，以及它的两个孩子：<code>left</code> 指针和 <code>right</code> 指针。</p></li><li><p><strong>探索子树</strong>：<code>left</code> 和 <code>right</code> 本身也是可以展开的节点对象！</p><ul><li><p>如果你想探索<strong>左子树</strong>，你就去展开 <code>left</code> 指针。</p></li><li><p>如果你想探索<strong>右子树</strong>，你就去展开 <code>right</code> 指针。</p></li></ul></li></ol><p><strong>这个过程就像是在一个文件管理器里一层一层地点开文件夹</strong>，你可以随心所欲地探索树的任何一个分支。</p><p>看起来会是这样：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nix">▼ <span class="hljs-params">root:</span> TreeNode (object)<br>  |-- <span class="hljs-params">val:</span> <span class="hljs-number">10</span><br>  ▼ <span class="hljs-params">left:</span> TreeNode (object)<br>  | |-- <span class="hljs-params">val:</span> <span class="hljs-number">5</span><br>  | |-- <span class="hljs-params">left:</span> <span class="hljs-literal">null</span><br>  | |-- <span class="hljs-params">right:</span> <span class="hljs-literal">null</span><br>  ▼ <span class="hljs-params">right:</span> TreeNode (object)<br>    |-- <span class="hljs-params">val:</span> <span class="hljs-number">15</span><br>    ▼ <span class="hljs-params">left:</span> TreeNode (object)<br>    | |-- <span class="hljs-params">val:</span> <span class="hljs-number">12</span><br>    | |-- ...<br>    |-- <span class="hljs-params">right:</span> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><hr><h3 id="高级技巧：配合“调用栈-Call-Stack-”理解递归"><a href="#高级技巧：配合“调用栈-Call-Stack-”理解递归" class="headerlink" title="高级技巧：配合“调用栈 (Call Stack)”理解递归"></a><strong>高级技巧：配合“调用栈 (Call Stack)”理解递归</strong></h3><p>当你调试树的遍历、搜索等递归算法时，还有一个大杀器——**“调用栈”窗口 (Call Stack)**。</p><ul><li><p><strong>它是什么</strong>：这个窗口会显示当前所有正在执行中的函数调用链。</p></li><li><p><strong>怎么用</strong>：当你用递归遍历一棵树时，每进入一层递归（比如从 <code>root</code> 调用 <code>traverse(root.left)</code>），调用栈里就会增加一层。每当一个递归调用返回时，调用栈就会减少一层。</p></li><li><p><strong>为什么强大</strong>：通过观察调用栈，你可以<strong>一目了然地知道当前你递归到了树的哪个节点，以及你是怎么一步步走到这里的</strong>。这对于理解复杂的递归过程，比如回溯算法，有着不可替代的作用。</p></li></ul><p><strong>总结一下：</strong></p><p>对于链表和树这种由指针&#x2F;引用连接起来的数据结构，IDE 调试器是<strong>最强大、最直观</strong>的分析工具。它通过<strong>可展开的视图</strong>让你能手动遍历整个数据结构，并通过<strong>调用栈</strong>让你能看清递归的轨迹。</p><h3 id="高级技巧：调用栈-Call-Stack-我们用“任务清单”来理解"><a href="#高级技巧：调用栈-Call-Stack-我们用“任务清单”来理解" class="headerlink" title="高级技巧：调用栈 (Call Stack) (我们用“任务清单”来理解)"></a><strong>高级技巧：调用栈 (Call Stack) (我们用“任务清单”来理解)</strong></h3><p>想象一下，你有一个非常聪明的助理，你给他派发任务。这个助理桌子上有一个<strong>“任务清单”</strong>，规则是：</p><ul><li><p>新任务来了，就压在清单的<strong>最上面</strong>。</p></li><li><p>他永远只做清单<strong>最顶上</strong>的那个任务。</p></li><li><p>做完了最顶上的任务，就把这个任务划掉，然后开始做下面的那个。</p></li></ul><p>这个“任务清单”就是**调用栈 (Call Stack)**。每一个函数调用，就是一个任务。</p><p><strong>用上面那个探险家的例子：</strong></p><ol><li><p><strong><code>main</code> 函数启动</strong>：你在清单上写下第一个任务：“开始探险 (<code>main</code> 函数)”。</p><ul><li><p><strong>清单:</strong></p><ul><li><code>main</code></li></ul></li></ul></li><li><p>**<code>main</code> 调用 <code>recursiveFunction(A)</code>**：你又写了个新任务“探索 A 路口”压在上面。助理开始做这个新任务。</p><ul><li><p><strong>清单:</strong></p><ul><li><p><code>recursiveFunction(A)</code></p></li><li><p><code>main</code></p></li></ul></li></ul></li><li><p>**在 <code>A</code> 任务中，调用 <code>recursiveFunction(B)</code>**：助理还没做完 <code>A</code> 的任务（他还要探索右边呢），但指令让他先探索 <code>B</code>。于是你又压上一个新任务“探索 B 路口”。</p><ul><li><p><strong>清单:</strong></p><ul><li><p><code>recursiveFunction(B)</code></p></li><li><p><code>recursiveFunction(A)</code></p></li><li><p><code>main</code></p></li></ul></li></ul></li><li><p><strong><code>B</code> 任务完成</strong>：B 路口探索完了（左右没路），助理把“探索 B 路口”这个任务从清单上划掉。</p><ul><li><p><strong>清单:</strong></p><ul><li><p><code>recursiveFunction(A)</code></p></li><li><p><code>main</code></p></li></ul></li></ul></li><li><p><strong>回到 <code>A</code> 任务</strong>：助理一看，清单最顶上的是“探索 A 路口”，他想起来了：“哦对，我刚才 A 的左边探索完了，现在该探索右边了”。</p></li></ol><p><strong>调用栈窗口在 IDE 里的作用</strong>，就是<strong>实时给你展示这张“任务清单”</strong>。</p><p>当你设置断点，程序暂停时，你看一眼调用栈窗口，就能知道：</p><ul><li><p><strong>当前在执行哪个任务？</strong> (清单最顶上的那个)</p></li><li><p><strong>这个任务是被谁派发的？</strong> (清单上它下面的那个)</p></li><li><p><strong>整个任务链条是怎样的？</strong> (看整个清单)</p></li></ul><p>这让你在复杂的递归调用中，永远不会迷失方向，能瞬间明白“我从哪里来，现在在哪里，要到哪里去”。</p><p>9&#x2F;9readed once</p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Debugging</tag>
      
      <tag>编程基础</tag>
      
      <tag>VS Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/09/07/hello-world/"/>
    <url>/2025/09/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一篇需要密码才能阅读的私密日记</title>
    <link href="/2025/09/07/%E4%B8%80%E7%AF%87%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E6%89%8D%E8%83%BD%E9%98%85%E8%AF%BB%E7%9A%84%E7%A7%81%E5%AF%86%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/09/07/%E4%B8%80%E7%AF%87%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E6%89%8D%E8%83%BD%E9%98%85%E8%AF%BB%E7%9A%84%E7%A7%81%E5%AF%86%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1331e21904297b95764b5ccbdae74bb5d121f1023e02249d125579ad4e224d20">165d50f05814027fb7fe5e4ae8a088d8f2d19fcd188202f6d199ff41c06cdd2bf22631a8834d1f794b554120a6dd7b133fcc0dcb84131f9a597962a3c4ed4af4a4459a144b5845becc8a2bda3e8a65f8c820320128fe1e54365e718d665a1f0f2276d335b699060618ce3c4eaf8037a614fde4c0bea8e6b5dcd65a856cd5602b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
    <tags>
      
      <tag>私密</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>遇到的问题与收获的经验教训</title>
    <link href="/2025/09/05/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B6%E8%8E%B7%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/"/>
    <url>/2025/09/05/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B6%E8%8E%B7%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/</url>
    
    <content type="html"><![CDATA[<ol><li>问题：PowerShell 权限不足，禁止运行脚本<br>现象：第一次尝试安装 Hexo 时，命令就失败了，并提示 UnauthorizedAccess（未经授权的访问）。</li></ol><p>原因：Windows PowerShell 出于安全考虑，默认禁止执行任何脚本，而 npm 命令需要调用一个脚本。</p><p>解决方案：以管理员身份打开 PowerShell，并执行 Set-ExecutionPolicy RemoteSigned 来调整安全策略。</p><p>经验教训：本地开发环境需要正确配置。 操作系统自带的安全特性有时会与开发工具冲突，学会根据报错信息调整环境配置是程序员的基本功。</p><ol start="2"><li>问题：hexo 命令无法被识别<br>现象：即使安装成功，输入 hexo init 时系统仍然提示找不到 hexo 这个命令。</li></ol><p>原因：npm 安装的全局工具所在的路径，没有被添加到系统的“环境变量 PATH”中，导致系统不知道去哪里找这个命令。</p><p>解决方案：找到 npm 的全局路径，并手动将其添加到系统的环境变量 Path 中。</p><p>经验教训：理解环境变量 PATH 的作用。 它是操作系统寻找命令的“地图”，是解决各种“命令找不到”问题的关键所在。</p><ol start="3"><li>问题：hexo deploy 部署时网络连接被重置<br>现象：可以正常浏览 GitHub 网站，但部署时反复出现 Recv failure: Connection was reset 错误。</li></ol><p>原因：浏览网页（HTTPS）和用 Git 上传文件是两种完全不同的网络传输方式。后者对网络连接的稳定性要求极高，容易受到不稳定网络、防火墙或代理的干扰。</p><p>解决方案：将部署方式从不稳定的 HTTPS 切换到更稳定、更专业的 SSH 协议。这需要生成 SSH 密钥并将其添加到 GitHub 账户中。</p><p>经验教训：问题要对症下药。 “能上网”不代表“网络适合所有任务”。针对特定的问题（如大文件、长时间的持续传输），需要选择更合适的工具或协议（SSH）来解决。</p><ol start="4"><li>问题：预览正常，但部署时提示 nothing to commit<br>现象：在本地用 hexo s 预览时能看到新文章，但 hexo d 部署时却提示没有改动，导致线上博客不更新。</li></ol><p>原因：这是典型的“构建缓存”或“脏数据”问题。本地预览可能使用了内存中的最新数据，但用于部署的 public 文件夹却是旧的、未被更新的。</p><p>解决方案：使用 hexo clean 命令。这个命令会强制删除旧的 public 文件夹和缓存，确保下一次生成和部署使用的是最新的源文件。</p><p>经验教训：学会清理缓存是重要的调试技巧。 当源代码和最终结果不一致时，首先要考虑是不是缓存导致的。hexo clean 是解决 Hexo 各种“玄学”问题的利器。</p><p>您的核心收获<br>工作流的掌握：您已经完整地掌握了 Hexo 博客的日常工作流：hexo new -&gt; 编辑和保存 -&gt; hexo s (预览) -&gt; hexo clean &amp;&amp; hexo d (清理并发布)。</p><p>调试能力的提升：您学会了如何根据报错信息一步步定位问题，从环境配置、网络协议，再到构建缓存，这套调试思路适用于未来遇到的任何技术问题。</p><p>信心的建立：您从一个简单的想法开始，通过自己的努力和坚持，解决了一路上所有的技术障碍，最终成功搭建并发布了属于自己的网站。这是最有价值的收获。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么浏览网页正常而Git上传会失败？</title>
    <link href="/2025/09/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%83%BD%E8%AE%BF%E9%97%AEGitHub%E5%8D%B4%E6%97%A0%E6%B3%95Deploy/"/>
    <url>/2025/09/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%83%BD%E8%AE%BF%E9%97%AEGitHub%E5%8D%B4%E6%97%A0%E6%B3%95Deploy/</url>
    
    <content type="html"><![CDATA[<p>简单来说：<strong>浏览网页和用 Git 上传文件，虽然目的地都是 GitHub，但它们走的“网络通道”和“数据传输方式”是完全不同的。</strong></p><p>我们可以用一个比喻来理解：</p><ul><li><p><strong>浏览 GitHub 网页</strong>：就像是<strong>寄一封信</strong>。这个动作非常快，数据量很小。即使中间邮路上有一个小坑洼（网络瞬间抖动），邮车也能轻松绕过去，信很快就送到了。</p></li><li><p><strong>用 <code>hexo deploy</code> (Git Push) 上传</strong>：这就像是<strong>开一辆大型集装箱卡车搬家</strong>。您需要把所有家当（整个网站的文件）一次性、持续不断地运送到目的地。这个过程有几个特点：</p><ol><li><p><strong>持续时间长</strong>：上传过程需要几十秒甚至更久，而不是像打开网页那样一瞬间。</p></li><li><p><strong>数据量大</strong>：您上传的是整个网站，数据量远大于看一个网页。</p></li><li><p><strong>对稳定性要求极高</strong>：在“搬家”的整个过程中，公路（网络连接）必须全程保持通畅。哪怕只是出现一个瞬间的“断裂”（<code>Connection was reset</code>），整个卡车（上传进程）就会“翻车”，任务失败。</p></li></ol></li></ul><h3 id="为什么能上网，但上传会失败？"><a href="#为什么能上网，但上传会失败？" class="headerlink" title="为什么能上网，但上传会失败？"></a>为什么能上网，但上传会失败？</h3><ol><li><p><strong>网络稳定性问题</strong>：您的网络在“寄信”（浏览网页）时看起来没问题，但在“开卡车”（长时间上传）时，任何微小的丢包或延迟都可能导致连接超时而被切断。<code>curl 28 Recv failure: Connection was reset</code> 这个错误，本质上就是一个<strong>超时或连接中断</strong>的错误。</p></li><li><p><strong>防火墙或网络代理的干扰</strong>：很多网络环境（比如公司、学校，甚至一些网络运营商）的防火墙，对于“寄信”这种普通网页浏览行为会完全放行。但是，当它们检测到一个长时间、大流量的加密上传时，可能会认为这是一种“可疑行为”并主动切断它，以确保网络安全。</p></li></ol><h3 id="这就是为什么我建议您换用-SSH-的原因"><a href="#这就是为什么我建议您换用-SSH-的原因" class="headerlink" title="这就是为什么我建议您换用 SSH 的原因"></a>这就是为什么我建议您换用 SSH 的原因</h3><p>继续用上面的比喻：</p><ul><li><p>您现在用的 <code>https://</code> 方式上传，就像是走一条<strong>公共高速公路</strong>。路上车多，检查站也多（防火墙），容易出问题。</p></li><li><p>而我建议您换用的 <code>SSH</code> 方式，就相当于您和 GitHub 之间建立了一条<strong>VIP 私人隧道</strong>。这条线路更稳定、更受信任，专门用于这种“搬家式”的数据传输，很少会受到外界干扰。</p></li></ul><p><strong>总结：</strong> 所以，虽然您的网络可以浏览网页，但在大文件持续上传时可能不稳定。请您尝试一下我上一步给出的【<strong>切换到 SSH</strong>】的完整方案，这有 99% 的概率能彻底解决您遇到的这个网络问题。 </p><p>检查是否修改，md</p>]]></content>
    
    
    <categories>
      
      <category>技术排错</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Git</tag>
      
      <tag>网络问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
