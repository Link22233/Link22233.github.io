<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-二分查找" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="article-date">
  <time class="dt-published" datetime="2025-10-15T03:00:00.000Z" itemprop="datePublished">2025-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">算法学习笔记：二分查找的两种写法与细节</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好的同学，我们来看新的内容：<strong>二分查找</strong>。</p>
<p>这是一个非常经典且高效的算法，但同时它也是一个“细节是魔鬼”的算法。很多人觉得懂了，但一写就错。你提供的这篇文章，作者“代码随想录”把二分查找的精髓讲得非常透彻。</p>
<p>他提出了一个核心观点：<strong>写二分查找，最重要的是要搞清楚你定义的区间是“闭”的还是“开”的，然后所有的细节都围绕这个定义来展开，形成统一的逻辑。</strong></p>
<p>我们来学习文章中提到的两种主要写法。</p>
<hr>
<h3 id="写法一：左闭右闭区间-left-right"><a href="#写法一：左闭右闭区间-left-right" class="headerlink" title="写法一：左闭右闭区间 [left, right]"></a>写法一：左闭右闭区间 <code>[left, right]</code></h3><p>这是最常见也最符合我们直觉的一种写法。</p>
<ol>
<li><p><strong>区间定义</strong>：我们的查找范围是 <code>[left, right]</code>，这意味着 <code>left</code> 和 <code>right</code> 这两个端点都是可以取到的有效值。</p>
<ul>
<li><code>left = 0</code>, <code>right = nums.length - 1</code></li>
</ul>
</li>
<li><p><strong>循环条件</strong>：因为 <code>left</code> 和 <code>right</code> 相等时是有意义的（比如数组只有一个元素 <code>[5]</code>，此时 <code>left=0</code>, <code>right=0</code>，这个区间是有效的），所以循环条件应该是 <code>while (left &lt;= right)</code>。</p>
</li>
<li><p>**中间值 <code>mid</code>**：<code>int mid = left + ((right - left) / 2);</code></p>
<ul>
<li><em>小提示：这样写是为了防止 <code>left + right</code> 的值过大导致整数溢出，效果等同于 <code>(left + right) / 2</code>，但更稳妥。</em></li>
</ul>
</li>
<li><p><strong>如何移动边界</strong>：这是最关键的细节！</p>
<ul>
<li>如果 <code>nums[mid] &gt; target</code>，说明 <code>target</code> 在 <code>mid</code> 的左边。因为我们当前的区间是 <code>[left, right]</code>，所以 <code>target</code> 可能的范围是 <code>[left, mid - 1]</code>。因此，下一步应该是 <code>right = mid - 1</code>。</li>
<li>如果 <code>nums[mid] &lt; target</code>，说明 <code>target</code> 在 <code>mid</code> 的右边，可能的范围是 <code>[mid + 1, right]</code>。因此，下一步应该是 <code>left = mid + 1</code>。</li>
<li>如果 <code>nums[mid] == target</code>，恭喜，找到了，直接返回 <code>mid</code> 就行。</li>
</ul>
</li>
</ol>
<p><strong>总结 <code>[left, right]</code> 写法的要点</strong>：</p>
<ul>
<li>循环条件是 <code>while (left &lt;= right)</code>。</li>
<li>因为 <code>mid</code> 已经被检查过了，所以移动边界时要跳过 <code>mid</code>，即 <code>right = mid - 1</code> 和 <code>left = mid + 1</code>。</li>
</ul>
<hr>
<h3 id="写法二：左闭右开区间-left-right"><a href="#写法二：左闭右开区间-left-right" class="headerlink" title="写法二：左闭右开区间 [left, right)"></a>写法二：左闭右开区间 <code>[left, right)</code></h3><p>这种写法在处理一些边界问题时有奇效，也值得我们掌握。</p>
<ol>
<li><p><strong>区间定义</strong>：我们的查找范围是 <code>[left, right)</code>，这意味着 <code>left</code> 可以取到，但 <code>right</code> <strong>不能</strong>取到，它只是一个边界。</p>
<ul>
<li><code>left = 0</code>, <code>right = nums.length</code> (注意，这里 <code>right</code> 的初始值和第一种写法不同)</li>
</ul>
</li>
<li><p><strong>循环条件</strong>：因为 <code>left</code> 和 <code>right</code> 相等时，区间 <code>[left, left)</code> 是一个空区间，没有意义，所以循环条件应该是 <code>while (left &lt; right)</code>。当 <code>left == right</code> 时，循环就应该停止。</p>
</li>
<li><p>**中间值 <code>mid</code>**：<code>int mid = left + ((right - left) / 2);</code> (计算方法不变)</p>
</li>
<li><p><strong>如何移动边界</strong>：</p>
<ul>
<li>如果 <code>nums[mid] &gt; target</code>，说明 <code>target</code> 在 <code>mid</code> 的左边。因为我们的右边界 <code>right</code> 是开区间，所以 <code>target</code> 的可能范围是 <code>[left, mid)</code>。因此，下一步应该是 <code>right = mid</code>。</li>
<li>如果 <code>nums[mid] &lt; target</code>，说明 <code>target</code> 在 <code>mid</code> 的右边，可能的范围是 <code>[mid + 1, right)</code>。因此，下一步应该是 <code>left = mid + 1</code>。</li>
<li>如果 <code>nums[mid] == target</code>，找到了，直接返回 <code>mid</code>。</li>
</ul>
</li>
</ol>
<p><strong>总结 <code>[left, right)</code> 写法的要点</strong>：</p>
<ul>
<li>循环条件是 <code>while (left &lt; right)</code>。</li>
<li>移动左边界时，因为 <code>mid</code> 已经检查过了，所以还是 <code>left = mid + 1</code>。</li>
<li>移动右边界时，因为 <code>right</code> 本身就是取不到的，所以新的右边界可以直接设为 <code>mid</code>，即 <code>right = mid</code>。</li>
</ul>
<hr>
<h3 id="额外需要关注的知识点"><a href="#额外需要关注的知识点" class="headerlink" title="额外需要关注的知识点"></a>额外需要关注的知识点</h3><ol>
<li><strong>前提条件</strong>：二分查找能使用的<strong>前提</strong>是：<strong>数组有序</strong>，并且数组中<strong>没有重复元素</strong>（如果有重复元素，查找逻辑会更复杂一些</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" data-id="cmgreyhv000069snd7a4yftut" data-title="算法学习笔记：二分查找的两种写法与细节" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Hexo 博客 PowerShell 发布完整流程笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/Hexo%20%E5%8D%9A%E5%AE%A2%20PowerShell%20%E5%8F%91%E5%B8%83%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T15:09:00.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>记录一下使用 PowerShell 发布 Hexo 博客的完整步骤，作为操作备份，防止遗忘。假设已经安装好了 Node. Js 和 Git 环境。</p>
<p>整个流程分为三步核心操作：<strong>新建文章 -&gt; 生成静态文件 -&gt; 部署到服务器</strong>。</p>
<h3 id="第-1-步：启动-PowerShell-并进入博客目录"><a href="#第-1-步：启动-PowerShell-并进入博客目录" class="headerlink" title="第 1 步：启动 PowerShell 并进入博客目录"></a>第 1 步：启动 PowerShell 并进入博客目录</h3><p>首先，你需要打开 PowerShell 终端，并切换到你的 Hexo 博客所在的根文件夹。</p>
<ol>
<li>按下 <code>Win + X</code> 键，然后选择 “Windows PowerShell” 或者 “终端”。</li>
<li>使用 <code>cd</code> 命令进入你的 Hexo 博客文件夹。例如，如果你的博客在 <code>D:\blog</code>：</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\blog</span><br><span class="line"><span class="literal">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 第 2 步：新建文章</span></span><br><span class="line"></span><br><span class="line">使用 `hexo new` 命令来创建一篇新的博文。文章的标题是必需的参数。</span><br><span class="line"></span><br><span class="line">PowerShell</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hexo new “你的文章标题”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">例如，创建一篇名为 &quot;Hello World&quot; 的文章：</span><br><span class="line"></span><br><span class="line">PowerShell</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hexo new “Hello World”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行后，Hexo 会在 `source/_posts` 文件夹里创建一个名为 `你的文章标题.md` 的 Markdown 文件。之后就可以用你喜欢的编辑器（如 VS Code, Sublime Text, Typora 等）打开这个文件开始写作了。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 第 3 步：生成并部署</span><br><span class="line"></span><br><span class="line">在你写完文章并保存之后，就到了发布的环节。这里有两个核心命令 `generate` 和 `deploy`。</span><br><span class="line"></span><br><span class="line">#### 清除缓存并生成静态文件 (`hexo g`)</span><br><span class="line"></span><br><span class="line">这个命令会把你的 Markdown 文章（`.md`）转换成网站所需的静态文件（如 `.html`, `.css`, `.js` 等）。</span><br><span class="line"></span><br><span class="line">PowerShell</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hexo clean &amp;&amp; hexo generate</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `hexo clean`: 清除之前生成过的旧文件缓存（即 `public` 文件夹），这可以避免一些潜在的缓存问题。</span><br><span class="line">    </span><br><span class="line">- `hexo generate` (可简写为 `hexo g`): 生成最新的网站文件，默认会存放在 `public` 文件夹里。</span><br><span class="line">    </span><br><span class="line">- `&amp;&amp;`: 这是一个连接符，表示先执行 `hexo clean` 命令，当它成功执行完毕后，再执行 `hexo generate` 命令。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">#### 部署到网站 (`hexo d`)</span><br><span class="line"></span><br><span class="line">这个命令会把 `public` 文件夹里的所有内容推送到你在 `_config.yml` 文件里配置好的 Git 仓库（比如 GitHub Pages）。</span><br><span class="line"></span><br><span class="line">PowerShell</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hexo deploy</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `hexo deploy` (可简写为 `hexo d`)</span><br><span class="line">    </span><br><span class="line">- 执行此命令时，PowerShell 可能会提示你输入 GitHub 的用户名和密码（或 Personal Access Token），根据提示输入即可完成推送。</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 总结：最常用的命令组合</span><br><span class="line"></span><br><span class="line">在你写完文章并保存后，只需要在 PowerShell 的博客根目录里，按顺序执行以下命令即可完成发布：</span><br><span class="line"></span><br><span class="line">PowerShell</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="1-新建文章-只需要在开始写作时用一次"><a href="#1-新建文章-只需要在开始写作时用一次" class="headerlink" title="1. 新建文章 (只需要在开始写作时用一次)"></a>1. 新建文章 (只需要在开始写作时用一次)</h1><p>hexo new “My New Post”</p>
<h1 id="2-写完文章后，一键生成并部署-这是最常用的组合"><a href="#2-写完文章后，一键生成并部署-这是最常用的组合" class="headerlink" title="2. 写完文章后，一键生成并部署 (这是最常用的组合)"></a>2. 写完文章后，一键生成并部署 (这是最常用的组合)</h1><p>hexo g -d</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里的 `hexo g -d` 是 `hexo generate --deploy` 的缩写，它会先执行生成操作，然后立刻执行部署操作，一步到位，非常方便。</span><br><span class="line"></span><br><span class="line">### 可选步骤：本地预览</span><br><span class="line"></span><br><span class="line">在发布到线上服务器之前，如果你想先在自己电脑上看看网站效果，可以使用本地预览命令：</span><br><span class="line"></span><br><span class="line">PowerShell</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>hexo server</p>
<pre><code>
- `hexo server` (可简写为 `hexo s`)
    

执行后，PowerShell 会显示一个网址，通常是 `http://localhost:4000`。在浏览器里打开这个网址，就可以实时预览你的博客效果了。确认所有内容显示无误后，在 PowerShell 窗口里按 `Ctrl + C` 停止本地服务器，然后再执行 `hexo g -d` 进行部署。
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/Hexo%20%E5%8D%9A%E5%AE%A2%20PowerShell%20%E5%8F%91%E5%B8%83%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/" data-id="cmgreyhus00009snd9b2gdfg4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SQL 学习笔记：用拼图游戏理解 JOIN" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/10/14/SQL%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%94%A8%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%90%86%E8%A7%A3%20JOIN/" class="article-date">
  <time class="dt-published" datetime="2025-10-14T15:01:00.000Z" itemprop="datePublished">2025-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="🧩-把-JOIN-想象成拼图"><a href="#🧩-把-JOIN-想象成拼图" class="headerlink" title="🧩 把 JOIN 想象成拼图"></a>🧩 把 JOIN 想象成拼图</h3><p>忘掉代码，我们来玩个游戏。</p>
<p>你有<strong>两盒拼图块</strong>：</p>
<p><strong>盒子 A (客户表 <code>Customers</code>)</strong></p>
<ul>
<li>每一块拼图上都有一个 <strong>客户 ID</strong> 和一个 <strong>客户名字</strong>。<ul>
<li><code>[ID: 101 | 名字: 张三]</code></li>
<li><code>[ID: 102 | 名字: 李四]</code></li>
</ul>
</li>
</ul>
<p><strong>盒子 B (订单表 <code>Orders</code>)</strong></p>
<ul>
<li>每一块拼图上都有一个 <strong>订单号</strong> 和一个 <strong>客户 ID</strong>。<ul>
<li><code>[订单号: 1 | ID: 101]</code></li>
<li><code>[订单号: 2 | ID: 102]</code></li>
<li><code>[订单号: 3 | ID: 101]</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="🎯-我们的目标"><a href="#🎯-我们的目标" class="headerlink" title="🎯 我们的目标"></a>🎯 我们的目标</h3><p>我们想知道<strong>每个订单号</strong>对应的<strong>客户名字</strong>是谁。</p>
<p>但是，<code>订单号</code> 在 <strong>B 盒</strong>，<code>客户名字</code> 在 <strong>A 盒</strong>。信息是分开的。</p>
<p><code>JOIN</code> 就是那个帮你**把能匹配的拼图块拼在一起</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/10/14/SQL%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%94%A8%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%90%86%E8%A7%A3%20JOIN/" data-id="cmgreyhuv00019sndhkhqanio" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-端口443如何解决SSH连接超时问题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/08/%E7%AB%AF%E5%8F%A3443%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3SSH%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2025-09-08T06:46:24.000Z" itemprop="datePublished">2025-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%8E%92%E9%94%99/">技术排错</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/08/%E7%AB%AF%E5%8F%A3443%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3SSH%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/">排错实录：端口443如何解决SSH连接超时问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一、遇到的问题：神秘的网络连接失败"><a href="#一、遇到的问题：神秘的网络连接失败" class="headerlink" title="一、遇到的问题：神秘的网络连接失败"></a>一、遇到的问题：神秘的网络连接失败</h3><p>今天，在我搭建和部署个人博客的过程中，我遇到了一个极其令人困惑的问题。当我满怀信心地在 PowerShell 中运行 <code>hexo deploy</code> 命令时，终端却无情地返回了网络错误：<br>ssh: connect to host github.com port 22: Connection timed out</p>
<p>最奇怪的是，我明明可以正常地用浏览器打开 GitHub 网站，登录、浏览都没有任何问题。为什么我的浏览器可以连接，而我的 PowerShell 却不行呢？这成了我今天需要解开的谜题。</p>
<h3 id="二、探寻真相：网页浏览和-SSH-连接有何不同？"><a href="#二、探寻真相：网页浏览和-SSH-连接有何不同？" class="headerlink" title="二、探寻真相：网页浏览和 SSH 连接有何不同？"></a>二、探寻真相：网页浏览和 SSH 连接有何不同？</h3><p>经过一番探索，我终于明白了问题的核心：<strong>能浏览网页，不代表所有开发工具都能正常联网。</strong></p>
<p>我们可以用一个“访问一栋安全大厦”的比喻来理解：</p>
<ul>
<li><strong>GitHub 服务器</strong>：就像一栋安保严密的大厦。</li>
<li>**网络端口 (Port)**：就是进入大厦的不同“门”。</li>
<li><strong>我的网络环境（防火墙）</strong>：就是大厦门口的“保安”。</li>
</ul>
<p>What is the Significance of Changing to Port 443?<br>改为443端口有什么意义？<br>The simple significance is that you are disguising your specialized traffic as common web traffic to bypass firewalls.<br>简单的意义是，您将专用流量伪装成常见的 Web 流量以绕过防火墙 。</p>
<p>To understand this, think of a server like GitHub as a large, secure building, and ports as the different doors into that building.<br>要理解这一点，请将像 GitHub 这样的服务器视为一个大型、安全的建筑物，而端口则是进入该建筑物的不同门。</p>
<p>Door #22 (The Default SSH Port): This is like a special, high-security employee-only entrance in the back of the building. It’s very efficient and secure, but for that very reason, many public places (like cafés, airports, or even strict home networks) keep this door locked and sealed (the firewall blocks port 22). When you tried to connect, you found this door was locked (Connection timed out).<br>门 #22（默认 SSH 端口）： 这就像大楼后面一个特殊的、高度安全的员工专用入口 。它非常高效和安全，但正是出于这个原因，许多公共场所（如咖啡馆、机场，甚至严格的家庭网络）都将这扇门锁上并密封（防火墙阻止了端口 22）。当您尝试连接时，您发现此门已锁定（ 连接超时 ）。</p>
<p>Door #443 (The HTTPS Port): This is the main public entrance to the building. It has a big “Welcome” sign and is used by millions of people every minute for secure web browsing (when you see https:&#x2F;&#x2F; in your browser). Because this door must be open for the internet to function, it is almost never blocked by any firewall.<br>门 #443（HTTPS 端口）： 这是大楼的主要公共入口 。它有一个很大的“欢迎”标志，每分钟有数百万人使用它来进行安全的网页浏览（当您在浏览器中看到 https:&#x2F;&#x2F; 时）。因为这扇门必须打开才能使互联网正常运行，所以它几乎从未被任何防火墙阻止 。</p>
<p>By creating the config file, you essentially told your computer: “Don’t bother trying the locked employee door (#22) anymore. Just go to the main public entrance (#443) and use your employee keycard there.”<br>通过创建配置文件 ，您实际上告诉您的计算机：“不要再费心尝试上锁的员工门 （#22）。只需前往主公共入口 （#443） 并在那里使用您的员工钥匙卡即可。</p>
<p>Is This Important for Programmers?<br>这对程序员来说重要吗？<br>Yes, absolutely. Understanding this concept is very important for a programmer. Here’s why:<br>是的，一点没错。理解这个概念对于程序员来说非常重要。 原因如下：</p>
<p>Real-World Environments: Programmers don’t always work on perfect, unrestricted networks. You will often find yourself working from a corporate office, a university, a client’s site, or a public Wi-Fi hotspot. All of these environments are likely to have firewalls that block standard developer ports like 22.<br>真实环境： 程序员并不总是在完美、不受限制的网络上工作。您经常会发现自己在公司办公室、大学、客户网站或公共 Wi-Fi 热点工作。所有这些环境都可能具有阻止标准开发人员端口（如 22）的防火墙。</p>
<p>Problem-Solving Ability: Knowing how to diagnose a blocked port and apply this workaround (tunneling over port 443) is a crucial real-world problem-solving skill. It can be the difference between being able to work and being completely stuck.<br>解决问题的能力： 了解如何诊断被阻止的端口并应用此解决方法（通过端口 443 进行隧道传输）是一项至关重要的实际问题解决技能。这可能是能够工作和完全陷入困境之间的区别。</p>
<p>Understanding the Full Picture: It shows an understanding that programming isn’t just about writing code. It’s also about understanding the networks and systems your code interacts with. Knowing how to navigate network restrictions is a mark of a practical and experienced developer.<br>了解全貌： 它表明了一种理解，即编程不仅仅是编写代码。它还涉及了解您的代码与之交互的网络和系统。知道如何应对网络限制是实用且经验丰富的开发人员的标志。</p>
<p>You just learned a valuable lesson that many programmers learn the hard way: your tools are only as good as your connection. Knowing how to make your tools work in a difficult network environment is a very important and practical skill that will serve you well in the future.<br>您刚刚学到了一个宝贵的教训，许多程序员都经历了艰难的教训： 您的工具的好坏取决于您的连接。 知道如何让您的工具在困难的网络环境中工作是一项非常重要且实用的技能，将来将为您服务。</p>
<h4 id="1-为什么浏览器能访问？"><a href="#1-为什么浏览器能访问？" class="headerlink" title="1. 为什么浏览器能访问？"></a>1. 为什么浏览器能访问？</h4><p>当我用浏览器访问 <code>https://github.com</code> 时，我走的是 **443 号门 (HTTPS 端口)**。这是大厦的“正门”，访客络绎不绝，所以保安（防火墙）默认这个门是安全且必须保持开放的，于是挥手放行。</p>
<h4 id="2-为什么-SSH-会失败？"><a href="#2-为什么-SSH-会失败？" class="headerlink" title="2. 为什么 SSH 会失败？"></a>2. 为什么 SSH 会失败？</h4><p>当我用 <code>hexo deploy</code> 或 <code>ssh</code> 命令时，程序默认尝试走的是 **22 号门 (SSH 端口)**。这像是大厦一个偏僻的“员工专用通道”。很多网络环境的保安（防火墙）为了安全，会把这个不常用的门锁死。我的请求根本到不了门口，自然就“连接超时”了。</p>
<h3 id="三、解决方案：让-SSH-“伪装”成浏览器流量"><a href="#三、解决方案：让-SSH-“伪装”成浏览器流量" class="headerlink" title="三、解决方案：让 SSH “伪装”成浏览器流量"></a>三、解决方案：让 SSH “伪装”成浏览器流量</h3><p>既然“员工通道”被锁了，那我能不能拿着我的员工卡（SSH 密钥）去走“正门”呢？答案是可以的！</p>
<p>解决方案就是修改我电脑上的 SSH 客户端配置，告诉它在连接 GitHub 的时候，不要走 22 号门，而是去走那个永远开放的 443 号门。</p>
<h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><ol>
<li><p><strong>找到或创建 SSH 配置文件</strong>：在 PowerShell 中用 <code>notepad ~/.ssh/config</code> 命令，在我的用户目录下创建了一个 <code>config</code> 文件。</p>
</li>
<li><p><strong>写入“绕路”规则</strong>：在 <code>config</code> 文件里，我粘贴了以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br><span class="line">  User git</span><br></pre></td></tr></table></figure>
<p>这个配置的意思是：“嘿，SSH客户端！下次要去 <code>github.com</code> 的时候，请改道去 <code>ssh.github.com</code> 这个地址，并且走 <code>443</code> 号门。”</p>
</li>
<li><p><strong>测试连接</strong>：保存文件后，我运行了测试命令 <code>ssh -T git@github.com</code>。</p>
<p>这一次，我没有再看到连接超时的错误，而是收到了来自 GitHub 的欢迎信息！</p>
<blockquote>
<p>Hi Link22233! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
</li>
</ol>
<h3 id="四、经验与教训"><a href="#四、经验与教训" class="headerlink" title="四、经验与教训"></a>四、经验与教训</h3><p>这次排错经历让我学到了非常重要的一课：</p>
<blockquote>
<p><strong>网络连接问题是分层且具体的。</strong> 不能简单地用“能上网”来判断连接性。</p>
</blockquote>
<p>一个程序的网络请求能否成功，取决于它的<strong>协议、目标地址和端口</strong>，以及这条路径上每一道“安检”（防火墙）的规则。</p>
<p>对于程序员来说，理解网络端口的基本概念，并掌握像修改 SSH 端口这样绕过网络限制的技巧，是一项非常实用且重要的能力。它能帮助我们在各种复杂的网络环境中保持生产力，而不是被一个简单的“连接超时”困住。</p>
<p>最终，这个小小的 <code>config</code> 文件，解决了困扰我许久的部署难题，也让我对网络问题的排查有了更深刻的理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/08/%E7%AB%AF%E5%8F%A3443%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3SSH%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/" data-id="cmgreyhv100089snd9x5x26c0" data-title="排错实录：端口443如何解决SSH连接超时问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AB%AF%E5%8F%A320/" rel="tag">端口20</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AB%AF%E5%8F%A3443/" rel="tag">端口443</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/" rel="tag">网络问题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" rel="tag">防火墙</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-编程学习笔记：代码调试 (Debugging) 的核心方法与技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%20(Debugging)%20%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2025-09-08T05:38:00.000Z" itemprop="datePublished">2025-09-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%20(Debugging)%20%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7/">编程学习笔记：代码调试 (Debugging) 的核心方法与技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="第一部分：核心思想——你和计算机的“误会”"><a href="#第一部分：核心思想——你和计算机的“误会”" class="headerlink" title="第一部分：核心思想——你和计算机的“误会”"></a><strong>第一部分：核心思想——你和计算机的“误会”</strong></h3><p>在你开始学习具体的技巧之前，一定要先理解这篇文章的核心思想，这非常非常重要：</p>
<blockquote>
<p><strong>当程序没有按你的预期运行时，几乎总是因为你对代码的理解和计算机实际执行的情况之间存在“误会”。代码永远是忠实地执行你写下的指令，而不是你脑子里想的那个指令。</strong></p>
</blockquote>
<p>Debug的过程，其实就是通过各种方法，去<strong>看清楚代码实际上是怎么一步一步执行的</strong>，从而找到你和计算机之间的那个“误会”到底在哪里。</p>
<hr>
<h3 id="第二部分：Debug-的四种层次"><a href="#第二部分：Debug-的四种层次" class="headerlink" title="第二部分：Debug 的四种层次"></a><strong>第二部分：Debug 的四种层次</strong></h3><p>文章提到了四种从易到难的 Debug 方法，帮你建立一个完整的概念：</p>
<ol>
<li><p><strong>直接读代码（人肉 Debug）</strong>：这是最基本的方法，通过一遍一遍地读代码，试图在脑子里模拟程序的运行，找出逻辑漏洞。对于初学者来说，这可能比较困难。</p>
</li>
<li><p><strong>求助 AI 工具</strong>：像 ChatGPT 这样的工具很强大，可以直接把有问题的代码丢给它，让它帮你找 bug 或者提供思路。这是一个很现代、很高效的方法。</p>
</li>
<li><p><strong>打印日志（打点观察）</strong>：<strong>这是我们这节课的重点！</strong> 通过在代码的关键位置插入打印语句（比如 <code>System.out.println</code>），输出变量的值或者程序的执行路径。这个方法虽然看起来“笨”，但极其有效。</p>
</li>
<li><p><strong>使用 IDE 的断点调试</strong>：这是最专业、最强大的方法，你可以在代码的任何地方设置一个“断点”，让程序运行到那里就暂停，然后你可以检查所有变量的状态，再单步执行。</p>
</li>
</ol>
<p>这篇教程的重点，就是教你如何精通第3种方法——<strong>“打印日志”</strong>，因为它能帮你深刻理解代码的执行流程。</p>
<hr>
<h3 id="第三部分：核心技巧——如何通过“打印”来破案"><a href="#第三部分：核心技巧——如何通过“打印”来破案" class="headerlink" title="第三部分：核心技巧——如何通过“打印”来破案"></a><strong>第三部分：核心技巧——如何通过“打印”来破案</strong></h3><p>接下来，我们来看文章里的几个关键案例，学习在不同场景下应该在哪里“打印”，打印什么内容。</p>
<h4 id="案例一：循环-for-循环"><a href="#案例一：循环-for-循环" class="headerlink" title="案例一：循环 (for 循环)"></a><strong>案例一：循环 (<code>for</code> 循环)</strong></h4><ul>
<li><p><strong>问题</strong>：循环的结果不对，不知道是循环次数错了，还是里面的计算错了。</p>
</li>
<li><p><strong>解决方法</strong>：在 <code>for</code> 循环<strong>内部</strong>打印出每一轮循环中，你最关心的那个变量的值。</p>
<p>  Java</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// for循环内部出现问题建议</span><br><span class="line">for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">    // 核心逻辑</span><br><span class="line">    System.out.println(&quot;在第 &quot; + i + &quot; 次循环时，变量X的值是: &quot; + x); // &lt;-- 在这里打印</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;循环结束&quot;); // &lt;-- 在循环外打印，确认循环是否正常结束</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>学习要点</strong>：通过在循环体内打印，你可以清晰地看到每一次迭代中变量的变化过程，一下子就能定位到是哪一轮出了问题。</p>
</li>
</ul>
<h4 id="案例二：链表或-while-循环"><a href="#案例二：链表或-while-循环" class="headerlink" title="案例二：链表或 while 循环"></a><strong>案例二：链表或 <code>while</code> 循环</strong></h4><ul>
<li><p><strong>问题</strong>：处理链表时，指针飞了，或者循环没有在预期的位置停下来。</p>
</li>
<li><p><strong>解决方法</strong>：在 <code>while</code> 循环<strong>内部</strong>，打印出当前节点的值，甚至下一个节点的值。</p>
<p>  Java</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while (list != null) &#123;</span><br><span class="line">    // 核心操作</span><br><span class="line">    System.out.println(&quot;当前节点值: &quot; + list.val + &quot; | 下一个节点是: &quot; + list.next); // &lt;-- 打印关键信息</span><br><span class="line">    list = list.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;循环结束后，list的值是: &quot; + list); // &lt;-- 检查结束时的状态</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>学习要点</strong>：对于链表、树这类数据结构，最重要的是观察“指针”或“引用”的变化。打印它们可以帮你追踪整个遍历过程。<br>  想象一下，<code>list</code> 这个变量不是一个普通变量，而是一个<strong>聚光灯</strong>。它的任务就是照亮链表中的某一个节点。</p>
</li>
</ul>
<p><code>list = list.next;</code> 这行代码的作用就是，把聚光灯从<strong>当前照亮的节点</strong>，移动到<strong>下一个节点</strong>去。</p>
<p><strong>那么，“指针飞了”是什么意思？</strong></p>
<p>就是这个聚光灯突然不听你指挥了！可能它照着照着，突然“唰”一下跳到了一个很远的、错误的节点上，或者“啪”一下熄灭了（变成了 <code>null</code>），而此时它后面明明还有很多节点没照亮。</p>
<p><strong>为什么 <code>println</code> 那么好用？</strong></p>
<p><code>System.out.println(&quot;当前节点值: &quot; + list.val + &quot; | 下一个节点是: &quot; + list.next);</code></p>
<p>这行代码就像是给聚光灯装了一个“状态播报器”。在聚光灯<strong>移动之前</strong>，它会大声喊出两件事：</p>
<ol>
<li><p><strong><code>&quot;当前节点值: &quot; + list.val</code></strong>: “报告！我现在正照着值为 <code>[val]</code> 的节点！” —— 这让你确定聚光灯当前的位置是正确的。</p>
</li>
<li><p><strong><code>&quot;下一个节点是: &quot; + list.next</code></strong>: “报告！我下一步准备移动到 <code>[next]</code> 这个位置去！” —— <strong>这才是关键！</strong> 它让你提前看到了聚光灯的<strong>移动目标</strong>。</p>
</li>
</ol>
<p><strong>举个例子：</strong> 假设你期望的输出是 <code>1 -&gt; 2 -&gt; 3</code>。</p>
<ul>
<li><p>当聚光灯照着 <code>1</code> 时，它播报：“我现在照着 1，下一步要去 2”。 <strong>（正常）</strong></p>
</li>
<li><p>然后聚光灯移动，照着 <code>2</code>，它播报：“我现在照着 2，下一步要去 3”。 <strong>（正常）</strong></p>
</li>
<li><p>突然，聚光灯照着 <code>3</code>，它播报：“我现在照着 3，下一步要去 null”。 <strong>（正常，到达终点）</strong></p>
</li>
</ul>
<p>但如果，照着 <code>2</code> 的时候，它突然播报：“我现在照着 2，下一步要去 null”。 你一下子就抓到问题了！根本不需要等到循环结束，你就知道在节点 <code>2</code> 这里，它的 <code>next</code> 指针出错了，导致链表“断”了。</p>
<p>这就是为什么这行 <code>println</code> 能帮你“预判”错误，抓住那个让聚光灯“飞了”的瞬间。</p>
<h4 id="案例三：条件判断-if-语句"><a href="#案例三：条件判断-if-语句" class="headerlink" title="案例三：条件判断 (if 语句)"></a><strong>案例三：条件判断 (<code>if</code> 语句)</strong></h4><ul>
<li><p><strong>问题</strong>：不确定程序到底有没有进入 <code>if</code> 的分支。</p>
</li>
<li><p><strong>解决方法</strong>：在 <code>if</code> 代码块<strong>内部</strong>放一个打印语句。</p>
<p>  Java</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">    System.out.println(&quot;程序成功进入了这个 if 分支&quot;); // &lt;-- 打印一个标记</span><br><span class="line">    // 核心逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>学习要点</strong>：如果你的控制台打印出了这句话，就证明条件判断为真，代码进来了。如果没打印，那就说明是 <code>condition</code> 本身出了问题。</p>
</li>
</ul>
<h4 id="案例四：递归"><a href="#案例四：递归" class="headerlink" title="案例四：递归"></a><strong>案例四：递归</strong></h4><ul>
<li><p><strong>问题</strong>：递归太抽象，不知道函数是怎么一层一层调用，又怎么一层一层返回的。</p>
</li>
<li><p><strong>解决方法</strong>：在递归函数的<strong>开头</strong>（进入下一层前）和<strong>结尾</strong>（返回上一层后）分别打印信息。</p>
<p>  Java</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void recursiveFunction(Node root) &#123;</span><br><span class="line">    if (root == null) return;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;进入节点: &quot; + root.val); // &lt;-- 递归调用前打印（前序遍历位置）</span><br><span class="line"></span><br><span class="line">    recursiveFunction(root.left); // 递归调用</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;离开节点: &quot; + root.val); // &lt;-- 递归调用后打印（后序遍历位置）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>学习要点</strong>：通过这种方式，你可以清晰地看到递归的“深入”和“回溯”过程，这对于理解递归的执行顺序至关重要。</p>
</li>
</ul>
<h3 id="案例四：递归和“进入-离开”-我们用“迷宫探险家”来理解"><a href="#案例四：递归和“进入-离开”-我们用“迷宫探险家”来理解" class="headerlink" title=". 案例四：递归和“进入&#x2F;离开” (我们用“迷宫探险家”来理解)"></a><strong>. 案例四：递归和“进入&#x2F;离开” (我们用“迷宫探险家”来理解)</strong></h3><p>想象一棵树是一个复杂的迷宫，而你的递归函数 <code>recursiveFunction</code> 就是一个<strong>探险家</strong>。</p>
<ul>
<li><p><strong><code>System.out.println(&quot;进入节点: &quot; + root.val);</code></strong> 这相当于探险家每到达迷宫中的一个<strong>新路口</strong>（一个节点），他就会用对讲机向你报告：“<strong>报告！我已到达 [val] 号路口！</strong>” 这个报告发生在他<strong>决定要继续深入探索</strong>（比如先走左边通道）<strong>之前</strong>。</p>
</li>
<li><p><strong><code>recursiveFunction(root.left);</code></strong> 这是探险家接到的指令：“从当前路口，进入左边的通道，把左边所有通道都走一遍。”</p>
</li>
<li><p><strong><code>System.out.println(&quot;离开节点: &quot; + root.val);</code></strong> 这相当于探险家<strong>已经把左边所有通道（以及分支、死路）全部探索完毕，并且回到了</strong>当前这个路口<strong>时</strong>，他再次用对讲机向你报告：“<strong>报告！我已经把 [val] 号路口的左边区域全部探索完毕，现在返回到了 [val] 号路口！</strong>”</p>
</li>
</ul>
<p><strong>把这些报告连起来看，会发生什么？</strong></p>
<p>假设树是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br></pre></td></tr></table></figure>

<p>你的控制台会打印出这样的日志：</p>
<ol>
<li><p>进入节点: A <em>(探险家到达 A)</em></p>
</li>
<li><p>进入节点: B <em>(他从 A 进入左边，到达 B)</em></p>
</li>
<li><p>离开节点: B <em>(B 的左右都没路了，他探索完 B，返回 A)</em></p>
</li>
<li><p>进入节点: C <em>(他回到 A 后，接到指令，进入右边，到达 C)</em></p>
</li>
<li><p>离开节点: C <em>(C 探索完毕，返回 A)</em></p>
</li>
<li><p>离开节点: A <em>(A 的左右两边都探索完毕了，他彻底离开 A)</em></p>
</li>
</ol>
<h2 id="看到了吗？通过“进入”和“离开”的配对打印，你就能完美地追踪出探险家在迷宫里的完整足迹，清清楚楚地看到他是如何深入，又是如何一步步返回（回溯）的。这就是理解递归执行顺序的关键。"><a href="#看到了吗？通过“进入”和“离开”的配对打印，你就能完美地追踪出探险家在迷宫里的完整足迹，清清楚楚地看到他是如何深入，又是如何一步步返回（回溯）的。这就是理解递归执行顺序的关键。" class="headerlink" title="看到了吗？通过“进入”和“离开”的配对打印，你就能完美地追踪出探险家在迷宫里的完整足迹，清清楚楚地看到他是如何深入，又是如何一步步返回（回溯）的。这就是理解递归执行顺序的关键。"></a>看到了吗？通过“进入”和“离开”的配对打印，你就能<strong>完美地追踪</strong>出探险家在迷宫里的完整足迹，清清楚楚地看到他是如何深入，又是如何一步步<strong>返回（回溯）</strong>的。这就是理解递归执行顺序的关键。</h2><h3 id="总结：这节课你学到了什么？"><a href="#总结：这节课你学到了什么？" class="headerlink" title="总结：这节课你学到了什么？"></a><strong>总结：这节课你学到了什么？</strong></h3><ol>
<li><p><strong>端正心态</strong>：Debug 不是和计算机吵架，而是去理解它到底是怎么执行你的代码的。</p>
</li>
<li><p><strong>掌握核心武器</strong>：学会使用 <code>System.out.println()</code> 这种最简单直接的方法来观察程序的内部状态。</p>
</li>
<li><p><strong>培养“盘感”</strong>：这种“笨办法”用多了，你对代码的执行流程会越来越敏感，慢慢地就能培养出一种直觉，以后看代码就能猜到哪里容易出错了。</p>
</li>
</ol>
<p>我们这堂课就来学习一下这个强大的功能。我们把它称为**断点调试 (Breakpoint Debugging)**。</p>
<hr>
<h3 id="核心概念：让程序“暂停”，让你“检查”"><a href="#核心概念：让程序“暂停”，让你“检查”" class="headerlink" title="核心概念：让程序“暂停”，让你“检查”"></a><strong>核心概念：让程序“暂停”，让你“检查”</strong></h3><p>想象一下，<code>println</code> 就像是在程序运行时，让变量自己大声喊出它的值。而断点调试，则更像是你拥有了<strong>“时间暂停”</strong>的超能力。</p>
<p>你可以在代码的任何一行设置一个“暂停点”（也就是<strong>断点</strong>），当程序运行到这里时，它会立刻“冻结”，然后IDE会把当前程序的所有状态，包括所有变量的值，都清清楚楚地展示给你。</p>
<hr>
<h3 id="如何操作：三步学会断点调试"><a href="#如何操作：三步学会断点调试" class="headerlink" title="如何操作：三步学会断点调试"></a><strong>如何操作：三步学会断点调试</strong></h3><p>在 VS 或 VS Code 里操作起来非常直观，主要就这几个步骤：</p>
<h4 id="第一步：设置断点-Set-a-Breakpoint"><a href="#第一步：设置断点-Set-a-Breakpoint" class="headerlink" title="第一步：设置断点 (Set a Breakpoint)"></a><strong>第一步：设置断点 (Set a Breakpoint)</strong></h4><p>在你想要程序暂停的那一行代码旁边，行号的左边，用鼠标<strong>点击一下</strong>。通常会出现一个<strong>红色的圆点</strong>。这就代表你在这里设置了一个断点。</p>
<ul>
<li><strong>什么时候设？</strong> 通常设在你怀疑有问题的代码行，或者是一个循环的开始、一个关键的 <code>if</code> 判断之前。</li>
</ul>
<h4 id="第二步：启动调试模式-Start-Debugging"><a href="#第二步：启动调试模式-Start-Debugging" class="headerlink" title="第二步：启动调试模式 (Start Debugging)"></a><strong>第二步：启动调试模式 (Start Debugging)</strong></h4><p>这一步很关键！你<strong>不能</strong>用平常的“运行”按钮。你需要找到并点击那个带有<strong>“虫子”图标 🐞</strong> 或者明确写着<strong>“调试” (Debug)</strong> 的启动按钮。</p>
<ul>
<li><p>在大多数 IDE 中，快捷键是 <code>F5</code>。</p>
</li>
<li><p>程序会开始运行，然后在它遇到的第一个断点处自动暂停。</p>
</li>
</ul>
<h4 id="第三步：观察变量并控制程序"><a href="#第三步：观察变量并控制程序" class="headerlink" title="第三步：观察变量并控制程序"></a><strong>第三步：观察变量并控制程序</strong></h4><p>一旦程序在断点处暂停，IDE 的界面会发生一些变化，通常会弹出几个新窗口，让你大显身手：</p>
<ol>
<li><p><strong>观察变量的值 (Inspecting Variables):</strong></p>
<ul>
<li><p><strong>变量窗口 (Variables Panel):</strong> 在左侧的调试面板中，会有一个“变量”区域，它会自动列出当前作用域内所有变量的实时值。你可以一层层展开对象或数组，查看里面的具体内容。</p>
</li>
<li><p><strong>鼠标悬停 (Hover):</strong> 这是最快的方法！直接在你的代码编辑器里，把鼠标光标移动到任何一个变量名上，稍等片刻，它的当前值就会弹出来。</p>
</li>
<li><p><strong>监视窗口 (Watch Panel):</strong> 你还可以把一些你特别关心的变量（甚至是一个表达式，比如 <code>a + b</code>）添加到“监视”窗口，这样无论程序走到哪里，只要这个变量存在，它的值都会被重点监控。</p>
</li>
</ul>
</li>
<li><p><strong>控制程序的执行流程 (Controlling the Flow):</strong> 在程序暂停时，调试工具栏上会出现几个像播放器一样的按钮，它们是你的“遥控器”：</p>
<ul>
<li><p><strong>继续 (Continue &#x2F; <code>F5</code>)</strong>: 让程序继续运行，直到遇到下一个断点或者程序结束。</p>
</li>
<li><p><strong>单步跳过 (Step Over &#x2F; <code>F10</code>)</strong>: 执行当前这一行代码，然后停在<strong>下一行</strong>。如果当前行是一个函数调用，它会执行完整个函数，但<strong>不会</strong>进入函数内部。</p>
</li>
<li><p><strong>单步调试 (Step Into &#x2F; <code>F11</code>)</strong>: 执行当前这一行。如果这一行是一个函数调用，它会<strong>进入</strong>到那个函数的内部，并停在函数的第一行。这对于追踪一个函数内部的问题非常有用。</p>
</li>
<li><p><strong>单步跳出 (Step Out &#x2F; <code>Shift+F11</code>)</strong>: 如果你已经进入了一个函数，这个按钮会执行完这个函数剩下的所有代码，然后返回到调用它的地方。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结：println-vs-断点调试"><a href="#总结：println-vs-断点调试" class="headerlink" title="总结：println vs. 断点调试"></a><strong>总结：<code>println</code> vs. 断点调试</strong></h3><p>现在你已经学会了两种强大的 Debug 方法，那应该在什么时候用哪个呢？</p>
<ul>
<li><p><strong>用 <code>println</code> 的场景:</strong></p>
<ul>
<li><p>问题比较简单，只想快速验证一个变量的值。</p>
</li>
<li><p>在一些不支持断点调试的环境中（比如某些服务器日志）。</p>
</li>
<li><p>调试和时间相关或者多线程的问题时，因为断点会让程序暂停，可能会改变问题的表现。</p>
</li>
</ul>
</li>
<li><p><strong>用断点调试的场景:</strong></p>
<ul>
<li><p><strong>绝大多数情况！</strong> 尤其是问题比较复杂，涉及很多变量和函数调用时。</p>
</li>
<li><p>当你想理解一段陌生代码的完整执行流程时。</p>
</li>
<li><p>当你需要检查大型对象或复杂数据结构的内容时。</p>
</li>
</ul>
</li>
</ul>
<p><strong>掌握 IDE 的断点调试功能，是每一个程序员从入门到专业的必经之路。</strong> 它的强大之处在于，它让你能真正地“看”到代码在执行，而不是靠“猜”。<br>当你调试的变量是一个链表或者一棵树时，IDE 的调试器会展现出它真正强大的地方。它<strong>不会</strong>只给你显示一个毫无意义的内存地址。</p>
<p>简单来说：<strong>调试器会用一个可以“展开”和“折叠”的视图，完美地把链表或树的结构给你呈现出来。</strong></p>
<p>我们来分别看一下这两种情况。</p>
<hr>
<h3 id="情况一：当变量是一个链表-Linked-List"><a href="#情况一：当变量是一个链表-Linked-List" class="headerlink" title="情况一：当变量是一个链表 (Linked List)"></a><strong>情况一：当变量是一个链表 (Linked List)</strong></h3><p>假设你有一个链表，你在代码里有一个指向链表头部的变量，比如叫 <code>head</code>。当你在断点处停下来时，你会这样做：</p>
<ol>
<li><p><strong>找到头节点</strong>：在调试器的“变量”窗口里，你会找到 <code>head</code> 这个变量。它旁边会有一个小小的三角形 <code>▶</code> 或者加号 <code>+</code>。</p>
</li>
<li><p><strong>展开第一个节点</strong>：你点击那个小三角形，<code>head</code> 变量就会被展开。你会看到这个节点内部的成员，比如它的值 <code>val</code> 和指向下一个节点的指针 <code>next</code>。</p>
</li>
<li><p><strong>顺藤摸瓜，查看下一个节点</strong>：现在，最神奇的地方来了！那个 <code>next</code> 指针本身也是一个可以展开的对象。你继续点击 <code>next</code> 旁边的 <code>▶</code>，调试器就会为你展示<strong>第二个节点</strong>的内容（它的 <code>val</code> 和它的 <code>next</code>）。</p>
</li>
<li><p><strong>一步步“走”完整个链表</strong>：你可以像这样，一层一层地点开 <code>next</code> -&gt; <code>next</code> -&gt; <code>next</code>… 就好像亲手把这个链条一环一环地解开一样。</p>
</li>
</ol>
<p>这个过程看起来会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">▼ head: ListNode (object)</span><br><span class="line">  |-- val: 1</span><br><span class="line">  ▼ next: ListNode (object)</span><br><span class="line">    |-- val: 2</span><br><span class="line">    ▼ next: ListNode (object)</span><br><span class="line">      |-- val: 3</span><br><span class="line">      |-- next: null  &lt;-- 你会清晰地看到链表的末尾！</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ul>
<li><p><strong>结构清晰</strong>：你能直观地看到节点是如何一个接一个连接起来的。</p>
</li>
<li><p><strong>轻松发现断链</strong>：如果某个节点的 <code>next</code> 意外地变成了 <code>null</code>，或者指向了一个错误的节点，你会立刻发现。</p>
</li>
<li><p><strong>识别循环链表</strong>：如果你不停地展开 <code>next</code>，发现又回到了之前的某个节点，那你就找到了一个环！</p>
</li>
</ul>
<hr>
<h3 id="情况二：当变量是一棵树-Tree"><a href="#情况二：当变量是一棵树-Tree" class="headerlink" title="情况二：当变量是一棵树 (Tree)"></a><strong>情况二：当变量是一棵树 (Tree)</strong></h3><p>调试树的逻辑和链表非常类似，只不过从“一维”的链条变成了“二维”的结构。</p>
<p>假设你有一个指向树根的变量 <code>root</code>。</p>
<ol>
<li><p><strong>找到根节点</strong>：在“变量”窗口里找到 <code>root</code> 变量。</p>
</li>
<li><p><strong>展开根节点</strong>：点击 <code>root</code> 旁边的 <code>▶</code>，你会看到根节点的值 <code>val</code>，以及它的两个孩子：<code>left</code> 指针和 <code>right</code> 指针。</p>
</li>
<li><p><strong>探索子树</strong>：<code>left</code> 和 <code>right</code> 本身也是可以展开的节点对象！</p>
<ul>
<li><p>如果你想探索<strong>左子树</strong>，你就去展开 <code>left</code> 指针。</p>
</li>
<li><p>如果你想探索<strong>右子树</strong>，你就去展开 <code>right</code> 指针。</p>
</li>
</ul>
</li>
</ol>
<p><strong>这个过程就像是在一个文件管理器里一层一层地点开文件夹</strong>，你可以随心所欲地探索树的任何一个分支。</p>
<p>看起来会是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">▼ root: TreeNode (object)</span><br><span class="line">  |-- val: 10</span><br><span class="line">  ▼ left: TreeNode (object)</span><br><span class="line">  | |-- val: 5</span><br><span class="line">  | |-- left: null</span><br><span class="line">  | |-- right: null</span><br><span class="line">  ▼ right: TreeNode (object)</span><br><span class="line">    |-- val: 15</span><br><span class="line">    ▼ left: TreeNode (object)</span><br><span class="line">    | |-- val: 12</span><br><span class="line">    | |-- ...</span><br><span class="line">    |-- right: null</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="高级技巧：配合“调用栈-Call-Stack-”理解递归"><a href="#高级技巧：配合“调用栈-Call-Stack-”理解递归" class="headerlink" title="高级技巧：配合“调用栈 (Call Stack)”理解递归"></a><strong>高级技巧：配合“调用栈 (Call Stack)”理解递归</strong></h3><p>当你调试树的遍历、搜索等递归算法时，还有一个大杀器——**“调用栈”窗口 (Call Stack)**。</p>
<ul>
<li><p><strong>它是什么</strong>：这个窗口会显示当前所有正在执行中的函数调用链。</p>
</li>
<li><p><strong>怎么用</strong>：当你用递归遍历一棵树时，每进入一层递归（比如从 <code>root</code> 调用 <code>traverse(root.left)</code>），调用栈里就会增加一层。每当一个递归调用返回时，调用栈就会减少一层。</p>
</li>
<li><p><strong>为什么强大</strong>：通过观察调用栈，你可以<strong>一目了然地知道当前你递归到了树的哪个节点，以及你是怎么一步步走到这里的</strong>。这对于理解复杂的递归过程，比如回溯算法，有着不可替代的作用。</p>
</li>
</ul>
<p><strong>总结一下：</strong></p>
<p>对于链表和树这种由指针&#x2F;引用连接起来的数据结构，IDE 调试器是<strong>最强大、最直观</strong>的分析工具。它通过<strong>可展开的视图</strong>让你能手动遍历整个数据结构，并通过<strong>调用栈</strong>让你能看清递归的轨迹。</p>
<h3 id="高级技巧：调用栈-Call-Stack-我们用“任务清单”来理解"><a href="#高级技巧：调用栈-Call-Stack-我们用“任务清单”来理解" class="headerlink" title="高级技巧：调用栈 (Call Stack) (我们用“任务清单”来理解)"></a><strong>高级技巧：调用栈 (Call Stack) (我们用“任务清单”来理解)</strong></h3><p>想象一下，你有一个非常聪明的助理，你给他派发任务。这个助理桌子上有一个<strong>“任务清单”</strong>，规则是：</p>
<ul>
<li><p>新任务来了，就压在清单的<strong>最上面</strong>。</p>
</li>
<li><p>他永远只做清单<strong>最顶上</strong>的那个任务。</p>
</li>
<li><p>做完了最顶上的任务，就把这个任务划掉，然后开始做下面的那个。</p>
</li>
</ul>
<p>这个“任务清单”就是**调用栈 (Call Stack)**。每一个函数调用，就是一个任务。</p>
<p><strong>用上面那个探险家的例子：</strong></p>
<ol>
<li><p><strong><code>main</code> 函数启动</strong>：你在清单上写下第一个任务：“开始探险 (<code>main</code> 函数)”。</p>
<ul>
<li><p><strong>清单:</strong></p>
<ul>
<li><code>main</code></li>
</ul>
</li>
</ul>
</li>
<li><p>**<code>main</code> 调用 <code>recursiveFunction(A)</code>**：你又写了个新任务“探索 A 路口”压在上面。助理开始做这个新任务。</p>
<ul>
<li><p><strong>清单:</strong></p>
<ul>
<li><p><code>recursiveFunction(A)</code></p>
</li>
<li><p><code>main</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>**在 <code>A</code> 任务中，调用 <code>recursiveFunction(B)</code>**：助理还没做完 <code>A</code> 的任务（他还要探索右边呢），但指令让他先探索 <code>B</code>。于是你又压上一个新任务“探索 B 路口”。</p>
<ul>
<li><p><strong>清单:</strong></p>
<ul>
<li><p><code>recursiveFunction(B)</code></p>
</li>
<li><p><code>recursiveFunction(A)</code></p>
</li>
<li><p><code>main</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>B</code> 任务完成</strong>：B 路口探索完了（左右没路），助理把“探索 B 路口”这个任务从清单上划掉。</p>
<ul>
<li><p><strong>清单:</strong></p>
<ul>
<li><p><code>recursiveFunction(A)</code></p>
</li>
<li><p><code>main</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>回到 <code>A</code> 任务</strong>：助理一看，清单最顶上的是“探索 A 路口”，他想起来了：“哦对，我刚才 A 的左边探索完了，现在该探索右边了”。</p>
</li>
</ol>
<p><strong>调用栈窗口在 IDE 里的作用</strong>，就是<strong>实时给你展示这张“任务清单”</strong>。</p>
<p>当你设置断点，程序暂停时，你看一眼调用栈窗口，就能知道：</p>
<ul>
<li><p><strong>当前在执行哪个任务？</strong> (清单最顶上的那个)</p>
</li>
<li><p><strong>这个任务是被谁派发的？</strong> (清单上它下面的那个)</p>
</li>
<li><p><strong>整个任务链条是怎样的？</strong> (看整个清单)</p>
</li>
</ul>
<p>这让你在复杂的递归调用中，永远不会迷失方向，能瞬间明白“我从哪里来，现在在哪里，要到哪里去”。</p>
<p>9&#x2F;9readed once</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%20(Debugging)%20%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7/" data-id="cmgreyhv200099snddetw0dm2" data-title="编程学习笔记：代码调试 (Debugging) 的核心方法与技巧" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Debugging/" rel="tag">Debugging</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VS-Code/" rel="tag">VS Code</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="tag">编程基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-一篇需要密码才能阅读的私密笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/07/%E4%B8%80%E7%AF%87%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E6%89%8D%E8%83%BD%E9%98%85%E8%AF%BB%E7%9A%84%E7%A7%81%E5%AF%86%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2025-09-07T03:00:00.000Z" itemprop="datePublished">2025-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/07/%E4%B8%80%E7%AF%87%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E6%89%8D%E8%83%BD%E9%98%85%E8%AF%BB%E7%9A%84%E7%A7%81%E5%AF%86%E7%AC%94%E8%AE%B0/">一篇需要密码才能阅读的私密日记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        Here's something encrypted, password is required to continue reading.
        
          <p class="article-more-link">
            <a href="/2025/09/07/%E4%B8%80%E7%AF%87%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E6%89%8D%E8%83%BD%E9%98%85%E8%AF%BB%E7%9A%84%E7%A7%81%E5%AF%86%E7%AC%94%E8%AE%B0/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/07/%E4%B8%80%E7%AF%87%E9%9C%80%E8%A6%81%E5%AF%86%E7%A0%81%E6%89%8D%E8%83%BD%E9%98%85%E8%AF%BB%E7%9A%84%E7%A7%81%E5%AF%86%E7%AC%94%E8%AE%B0/" data-id="cmgreyhux00039sndawst8agv" data-title="一篇需要密码才能阅读的私密日记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%81%E5%AF%86/" rel="tag">私密</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-遇到的问题与收获的经验教训" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/05/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B6%E8%8E%B7%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" class="article-date">
  <time class="dt-published" datetime="2025-09-05T15:46:28.000Z" itemprop="datePublished">2025-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/05/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B6%E8%8E%B7%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/">遇到的问题与收获的经验教训</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>问题：PowerShell 权限不足，禁止运行脚本<br>现象：第一次尝试安装 Hexo 时，命令就失败了，并提示 UnauthorizedAccess（未经授权的访问）。</li>
</ol>
<p>原因：Windows PowerShell 出于安全考虑，默认禁止执行任何脚本，而 npm 命令需要调用一个脚本。</p>
<p>解决方案：以管理员身份打开 PowerShell，并执行 Set-ExecutionPolicy RemoteSigned 来调整安全策略。</p>
<p>经验教训：本地开发环境需要正确配置。 操作系统自带的安全特性有时会与开发工具冲突，学会根据报错信息调整环境配置是程序员的基本功。</p>
<ol start="2">
<li>问题：hexo 命令无法被识别<br>现象：即使安装成功，输入 hexo init 时系统仍然提示找不到 hexo 这个命令。</li>
</ol>
<p>原因：npm 安装的全局工具所在的路径，没有被添加到系统的“环境变量 PATH”中，导致系统不知道去哪里找这个命令。</p>
<p>解决方案：找到 npm 的全局路径，并手动将其添加到系统的环境变量 Path 中。</p>
<p>经验教训：理解环境变量 PATH 的作用。 它是操作系统寻找命令的“地图”，是解决各种“命令找不到”问题的关键所在。</p>
<ol start="3">
<li>问题：hexo deploy 部署时网络连接被重置<br>现象：可以正常浏览 GitHub 网站，但部署时反复出现 Recv failure: Connection was reset 错误。</li>
</ol>
<p>原因：浏览网页（HTTPS）和用 Git 上传文件是两种完全不同的网络传输方式。后者对网络连接的稳定性要求极高，容易受到不稳定网络、防火墙或代理的干扰。</p>
<p>解决方案：将部署方式从不稳定的 HTTPS 切换到更稳定、更专业的 SSH 协议。这需要生成 SSH 密钥并将其添加到 GitHub 账户中。</p>
<p>经验教训：问题要对症下药。 “能上网”不代表“网络适合所有任务”。针对特定的问题（如大文件、长时间的持续传输），需要选择更合适的工具或协议（SSH）来解决。</p>
<ol start="4">
<li>问题：预览正常，但部署时提示 nothing to commit<br>现象：在本地用 hexo s 预览时能看到新文章，但 hexo d 部署时却提示没有改动，导致线上博客不更新。</li>
</ol>
<p>原因：这是典型的“构建缓存”或“脏数据”问题。本地预览可能使用了内存中的最新数据，但用于部署的 public 文件夹却是旧的、未被更新的。</p>
<p>解决方案：使用 hexo clean 命令。这个命令会强制删除旧的 public 文件夹和缓存，确保下一次生成和部署使用的是最新的源文件。</p>
<p>经验教训：学会清理缓存是重要的调试技巧。 当源代码和最终结果不一致时，首先要考虑是不是缓存导致的。hexo clean 是解决 Hexo 各种“玄学”问题的利器。</p>
<p>您的核心收获<br>工作流的掌握：您已经完整地掌握了 Hexo 博客的日常工作流：hexo new -&gt; 编辑和保存 -&gt; hexo s (预览) -&gt; hexo clean &amp;&amp; hexo d (清理并发布)。</p>
<p>调试能力的提升：您学会了如何根据报错信息一步步定位问题，从环境配置、网络协议，再到构建缓存，这套调试思路适用于未来遇到的任何技术问题。</p>
<p>信心的建立：您从一个简单的想法开始，通过自己的努力和坚持，解决了一路上所有的技术障碍，最终成功搭建并发布了属于自己的网站。这是最有价值的收获。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/05/%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B6%E8%8E%B7%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/" data-id="cmgreyhv3000c9sndgh6i1qlr" data-title="遇到的问题与收获的经验教训" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/05/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-09-05T14:05:45.099Z" itemprop="datePublished">2025-09-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/05/hello-world/" data-id="cmgreyhuw00029snd2ye29ryf" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-为什么我能访问GitHub却无法Deploy" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%83%BD%E8%AE%BF%E9%97%AEGitHub%E5%8D%B4%E6%97%A0%E6%B3%95Deploy/" class="article-date">
  <time class="dt-published" datetime="2025-09-05T03:23:00.000Z" itemprop="datePublished">2025-09-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%8E%92%E9%94%99/">技术排错</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%83%BD%E8%AE%BF%E9%97%AEGitHub%E5%8D%B4%E6%97%A0%E6%B3%95Deploy/">为什么浏览网页正常而Git上传会失败？</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>简单来说：<strong>浏览网页和用 Git 上传文件，虽然目的地都是 GitHub，但它们走的“网络通道”和“数据传输方式”是完全不同的。</strong></p>
<p>我们可以用一个比喻来理解：</p>
<ul>
<li><p><strong>浏览 GitHub 网页</strong>：就像是<strong>寄一封信</strong>。这个动作非常快，数据量很小。即使中间邮路上有一个小坑洼（网络瞬间抖动），邮车也能轻松绕过去，信很快就送到了。</p>
</li>
<li><p><strong>用 <code>hexo deploy</code> (Git Push) 上传</strong>：这就像是<strong>开一辆大型集装箱卡车搬家</strong>。您需要把所有家当（整个网站的文件）一次性、持续不断地运送到目的地。这个过程有几个特点：</p>
<ol>
<li><p><strong>持续时间长</strong>：上传过程需要几十秒甚至更久，而不是像打开网页那样一瞬间。</p>
</li>
<li><p><strong>数据量大</strong>：您上传的是整个网站，数据量远大于看一个网页。</p>
</li>
<li><p><strong>对稳定性要求极高</strong>：在“搬家”的整个过程中，公路（网络连接）必须全程保持通畅。哪怕只是出现一个瞬间的“断裂”（<code>Connection was reset</code>），整个卡车（上传进程）就会“翻车”，任务失败。</p>
</li>
</ol>
</li>
</ul>
<h3 id="为什么能上网，但上传会失败？"><a href="#为什么能上网，但上传会失败？" class="headerlink" title="为什么能上网，但上传会失败？"></a>为什么能上网，但上传会失败？</h3><ol>
<li><p><strong>网络稳定性问题</strong>：您的网络在“寄信”（浏览网页）时看起来没问题，但在“开卡车”（长时间上传）时，任何微小的丢包或延迟都可能导致连接超时而被切断。<code>curl 28 Recv failure: Connection was reset</code> 这个错误，本质上就是一个<strong>超时或连接中断</strong>的错误。</p>
</li>
<li><p><strong>防火墙或网络代理的干扰</strong>：很多网络环境（比如公司、学校，甚至一些网络运营商）的防火墙，对于“寄信”这种普通网页浏览行为会完全放行。但是，当它们检测到一个长时间、大流量的加密上传时，可能会认为这是一种“可疑行为”并主动切断它，以确保网络安全。</p>
</li>
</ol>
<h3 id="这就是为什么我建议您换用-SSH-的原因"><a href="#这就是为什么我建议您换用-SSH-的原因" class="headerlink" title="这就是为什么我建议您换用 SSH 的原因"></a>这就是为什么我建议您换用 SSH 的原因</h3><p>继续用上面的比喻：</p>
<ul>
<li><p>您现在用的 <code>https://</code> 方式上传，就像是走一条<strong>公共高速公路</strong>。路上车多，检查站也多（防火墙），容易出问题。</p>
</li>
<li><p>而我建议您换用的 <code>SSH</code> 方式，就相当于您和 GitHub 之间建立了一条<strong>VIP 私人隧道</strong>。这条线路更稳定、更受信任，专门用于这种“搬家式”的数据传输，很少会受到外界干扰。</p>
</li>
</ul>
<p><strong>总结：</strong> 所以，虽然您的网络可以浏览网页，但在大文件持续上传时可能不稳定。请您尝试一下我上一步给出的【<strong>切换到 SSH</strong>】的完整方案，这有 99% 的概率能彻底解决您遇到的这个网络问题。 </p>
<p>检查是否修改，md</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%83%BD%E8%AE%BF%E9%97%AEGitHub%E5%8D%B4%E6%97%A0%E6%B3%95Deploy/" data-id="cmgreyhuy00049sndba5a8uex" data-title="为什么浏览网页正常而Git上传会失败？" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/" rel="tag">网络问题</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E6%8E%92%E9%94%99/">技术排错</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/">算法笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Debugging/" rel="tag">Debugging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VS-Code/" rel="tag">VS Code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%81%E5%AF%86/" rel="tag">私密</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AB%AF%E5%8F%A320/" rel="tag">端口20</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AB%AF%E5%8F%A3443/" rel="tag">端口443</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="tag">编程基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/" rel="tag">网络问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" rel="tag">防火墙</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Debugging/" style="font-size: 10px;">Debugging</a> <a href="/tags/Git/" style="font-size: 20px;">Git</a> <a href="/tags/Hexo/" style="font-size: 20px;">Hexo</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 10px;">LeetCode</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/VS-Code/" style="font-size: 10px;">VS Code</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 10px;">二分查找</a> <a href="/tags/%E7%A7%81%E5%AF%86/" style="font-size: 10px;">私密</a> <a href="/tags/%E7%AB%AF%E5%8F%A320/" style="font-size: 10px;">端口20</a> <a href="/tags/%E7%AB%AF%E5%8F%A3443/" style="font-size: 10px;">端口443</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">编程基础</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/" style="font-size: 20px;">网络问题</a> <a href="/tags/%E9%98%B2%E7%81%AB%E5%A2%99/" style="font-size: 10px;">防火墙</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">September 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/">算法学习笔记：二分查找的两种写法与细节</a>
          </li>
        
          <li>
            <a href="/2025/10/14/Hexo%20%E5%8D%9A%E5%AE%A2%20PowerShell%20%E5%8F%91%E5%B8%83%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/10/14/SQL%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%94%A8%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%90%86%E8%A7%A3%20JOIN/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/09/08/%E7%AB%AF%E5%8F%A3443%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3SSH%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/">排错实录：端口443如何解决SSH连接超时问题</a>
          </li>
        
          <li>
            <a href="/2025/09/08/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%20(Debugging)%20%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E4%B8%8E%E6%8A%80%E5%B7%A7/">编程学习笔记：代码调试 (Debugging) 的核心方法与技巧</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>